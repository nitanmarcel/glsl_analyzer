{
  "comment": "generated from docs.gl",
  "keywords": [
    {
      "kind": "glsl",
      "name": "BIOME_DESERT"
    },
    {
      "kind": "glsl",
      "name": "BIOME_PLAINS"
    },
    {
      "kind": "glsl",
      "name": "BIOME_RIVER"
    },
    {
      "kind": "glsl",
      "name": "BIOME_SWAMP"
    },
    {
      "kind": "glsl",
      "name": "CAT_BEACH"
    },
    {
      "kind": "glsl",
      "name": "CAT_DESERT"
    },
    {
      "kind": "glsl",
      "name": "CAT_EXTREME_HILLS"
    },
    {
      "kind": "glsl",
      "name": "CAT_FOREST"
    },
    {
      "kind": "glsl",
      "name": "CAT_ICY"
    },
    {
      "kind": "glsl",
      "name": "CAT_JUNGLE"
    },
    {
      "kind": "glsl",
      "name": "CAT_MESA"
    },
    {
      "kind": "glsl",
      "name": "CAT_MUSHROOM"
    },
    {
      "kind": "glsl",
      "name": "CAT_NETHER"
    },
    {
      "kind": "glsl",
      "name": "CAT_NONE"
    },
    {
      "kind": "glsl",
      "name": "CAT_OCEAN"
    },
    {
      "kind": "glsl",
      "name": "CAT_PLAINS"
    },
    {
      "kind": "glsl",
      "name": "CAT_RIVER"
    },
    {
      "kind": "glsl",
      "name": "CAT_SAVANNA"
    },
    {
      "kind": "glsl",
      "name": "CAT_SWAMP"
    },
    {
      "kind": "glsl",
      "name": "CAT_TAIGA"
    },
    {
      "kind": "glsl",
      "name": "CAT_THE_END"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_BLOCK_EMISSION_ATTRIBUTE"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_COMPUTE_SHADERS"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_CUSTOM_IMAGES"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_ENTITY_TRANSLUCENT"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_HIGHER_SHADOWCOLOR"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_PER_BUFFER_BLENDING"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_REVERSED_CULLING"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_SEPARATE_HARDWARE_SAMPLERS"
    },
    {
      "kind": "glsl",
      "name": "IRIS_FEATURE_SSBO"
    },
    {
      "kind": "glsl",
      "name": "IS_IRIS"
    },
    {
      "kind": "glsl",
      "name": "MC_ANISOTROPIC_FILTERING"
    },
    {
      "kind": "glsl",
      "name": "MC_FXAA_LEVEL"
    },
    {
      "kind": "glsl",
      "name": "MC_GLSL_VERSION"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_GALLIUM"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_GEFORCE"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_INTEL"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_MESA"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_OTHER"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_QUADRO"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_RENDERER_RADEON"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_AMD"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_ATI"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_INTEL"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_MESA"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_NVIDIA"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_OTHER"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VENDOR_XORG"
    },
    {
      "kind": "glsl",
      "name": "MC_GL_VERSION"
    },
    {
      "kind": "glsl",
      "name": "MC_HAND_DEPTH"
    },
    {
      "kind": "glsl",
      "name": "MC_NORMAL_MAP"
    },
    {
      "kind": "glsl",
      "name": "MC_OLD_HAND_LIGHT"
    },
    {
      "kind": "glsl",
      "name": "MC_OLD_LIGHTING"
    },
    {
      "kind": "glsl",
      "name": "MC_OS_LINUX"
    },
    {
      "kind": "glsl",
      "name": "MC_OS_MAC"
    },
    {
      "kind": "glsl",
      "name": "MC_OS_OTHER"
    },
    {
      "kind": "glsl",
      "name": "MC_OS_WINDOWS"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_QUALITY"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_BLOCK_ENTITIES"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_CLOUDS"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_CUSTOM_SKY"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_DEBUG"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_DESTROY"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_ENTITIES"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_HAND_SOLID"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_HAND_TRANSLUCENT"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_MOON"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_NONE"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_OUTLINE"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_PARTICLES"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_RAIN_SNOW"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_SKY"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_STARS"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_SUN"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_SUNSET"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_TERRAIN_CUTOUT"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_TERRAIN_CUTOUT_MIPPED"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_TERRAIN_SOLID"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_TERRAIN_TRANSLUCENT"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_TRIPWIRE"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_VOID"
    },
    {
      "kind": "glsl",
      "name": "MC_RENDER_STAGE_WORLD_BORDER"
    },
    {
      "kind": "glsl",
      "name": "MC_SHADOW_QUALITY"
    },
    {
      "kind": "glsl",
      "name": "MC_SPECULAR_MAP"
    },
    {
      "kind": "glsl",
      "name": "MC_TEXTURE_FORMAT_LAB_PBR"
    },
    {
      "kind": "glsl",
      "name": "MC_TEXTURE_FORMAT_LAB_PBR_1_3"
    },
    {
      "kind": "glsl",
      "name": "MC_VERSION"
    },
    {
      "kind": "glsl",
      "name": "PPT_NONE"
    },
    {
      "kind": "glsl",
      "name": "PPT_RAIN"
    },
    {
      "kind": "glsl",
      "name": "PPT_SNOW"
    },
    {
      "name": "active",
      "kind": "reserved"
    },
    {
      "name": "asm",
      "kind": "reserved"
    },
    {
      "name": "atomic_uint",
      "kind": "glsl"
    },
    {
      "name": "attribute",
      "kind": "glsl"
    },
    {
      "name": "bool",
      "kind": "glsl"
    },
    {
      "name": "break",
      "kind": "glsl"
    },
    {
      "name": "buffer",
      "kind": "glsl"
    },
    {
      "name": "bvec2",
      "kind": "glsl"
    },
    {
      "name": "bvec3",
      "kind": "glsl"
    },
    {
      "name": "bvec4",
      "kind": "glsl"
    },
    {
      "name": "case",
      "kind": "glsl"
    },
    {
      "name": "cast",
      "kind": "reserved"
    },
    {
      "name": "centroid",
      "kind": "glsl"
    },
    {
      "name": "class",
      "kind": "reserved"
    },
    {
      "name": "coherent",
      "kind": "glsl"
    },
    {
      "name": "common",
      "kind": "reserved"
    },
    {
      "name": "const",
      "kind": "glsl"
    },
    {
      "name": "continue",
      "kind": "glsl"
    },
    {
      "name": "default",
      "kind": "glsl"
    },
    {
      "name": "discard",
      "kind": "glsl"
    },
    {
      "name": "dmat2",
      "kind": "glsl"
    },
    {
      "name": "dmat2x2",
      "kind": "glsl"
    },
    {
      "name": "dmat2x3",
      "kind": "glsl"
    },
    {
      "name": "dmat2x4",
      "kind": "glsl"
    },
    {
      "name": "dmat3",
      "kind": "glsl"
    },
    {
      "name": "dmat3x2",
      "kind": "glsl"
    },
    {
      "name": "dmat3x3",
      "kind": "glsl"
    },
    {
      "name": "dmat3x4",
      "kind": "glsl"
    },
    {
      "name": "dmat4",
      "kind": "glsl"
    },
    {
      "name": "dmat4x2",
      "kind": "glsl"
    },
    {
      "name": "dmat4x3",
      "kind": "glsl"
    },
    {
      "name": "dmat4x4",
      "kind": "glsl"
    },
    {
      "name": "do",
      "kind": "glsl"
    },
    {
      "name": "double",
      "kind": "glsl"
    },
    {
      "name": "dvec2",
      "kind": "glsl"
    },
    {
      "name": "dvec3",
      "kind": "glsl"
    },
    {
      "name": "dvec4",
      "kind": "glsl"
    },
    {
      "name": "else",
      "kind": "glsl"
    },
    {
      "name": "enum",
      "kind": "reserved"
    },
    {
      "name": "extern",
      "kind": "reserved"
    },
    {
      "name": "external",
      "kind": "reserved"
    },
    {
      "name": "false",
      "kind": "glsl"
    },
    {
      "name": "filter",
      "kind": "reserved"
    },
    {
      "name": "fixed",
      "kind": "reserved"
    },
    {
      "name": "flat",
      "kind": "glsl"
    },
    {
      "name": "float",
      "kind": "glsl"
    },
    {
      "name": "for",
      "kind": "glsl"
    },
    {
      "name": "fvec2",
      "kind": "reserved"
    },
    {
      "name": "fvec3",
      "kind": "reserved"
    },
    {
      "name": "fvec4",
      "kind": "reserved"
    },
    {
      "name": "goto",
      "kind": "reserved"
    },
    {
      "name": "half",
      "kind": "reserved"
    },
    {
      "name": "highp",
      "kind": "glsl"
    },
    {
      "name": "hvec2",
      "kind": "reserved"
    },
    {
      "name": "hvec3",
      "kind": "reserved"
    },
    {
      "name": "hvec4",
      "kind": "reserved"
    },
    {
      "name": "if",
      "kind": "glsl"
    },
    {
      "name": "iimage1D",
      "kind": "glsl"
    },
    {
      "name": "iimage1DArray",
      "kind": "glsl"
    },
    {
      "name": "iimage2D",
      "kind": "glsl"
    },
    {
      "name": "iimage2DArray",
      "kind": "glsl"
    },
    {
      "name": "iimage2DMS",
      "kind": "glsl"
    },
    {
      "name": "iimage2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "iimage2DRect",
      "kind": "glsl"
    },
    {
      "name": "iimage3D",
      "kind": "glsl"
    },
    {
      "name": "iimageBuffer",
      "kind": "glsl"
    },
    {
      "name": "iimageCube",
      "kind": "glsl"
    },
    {
      "name": "iimageCubeArray",
      "kind": "glsl"
    },
    {
      "name": "image1D",
      "kind": "glsl"
    },
    {
      "name": "image1DArray",
      "kind": "glsl"
    },
    {
      "name": "image2D",
      "kind": "glsl"
    },
    {
      "name": "image2DArray",
      "kind": "glsl"
    },
    {
      "name": "image2DMS",
      "kind": "glsl"
    },
    {
      "name": "image2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "image2DRect",
      "kind": "glsl"
    },
    {
      "name": "image3D",
      "kind": "glsl"
    },
    {
      "name": "imageBuffer",
      "kind": "glsl"
    },
    {
      "name": "imageCube",
      "kind": "glsl"
    },
    {
      "name": "imageCubeArray",
      "kind": "glsl"
    },
    {
      "name": "in",
      "kind": "glsl"
    },
    {
      "name": "inline",
      "kind": "reserved"
    },
    {
      "name": "inout",
      "kind": "glsl"
    },
    {
      "name": "input",
      "kind": "reserved"
    },
    {
      "name": "int",
      "kind": "glsl"
    },
    {
      "name": "interface",
      "kind": "reserved"
    },
    {
      "name": "invariant",
      "kind": "glsl"
    },
    {
      "name": "isampler1D",
      "kind": "glsl"
    },
    {
      "name": "isampler1DArray",
      "kind": "glsl"
    },
    {
      "name": "isampler2D",
      "kind": "glsl"
    },
    {
      "name": "isampler2DArray",
      "kind": "glsl"
    },
    {
      "name": "isampler2DMS",
      "kind": "glsl"
    },
    {
      "name": "isampler2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "isampler2DRect",
      "kind": "glsl"
    },
    {
      "name": "isampler3D",
      "kind": "glsl"
    },
    {
      "name": "isamplerBuffer",
      "kind": "glsl"
    },
    {
      "name": "isamplerCube",
      "kind": "glsl"
    },
    {
      "name": "isamplerCubeArray",
      "kind": "glsl"
    },
    {
      "name": "isubpassInput",
      "kind": "vulkan"
    },
    {
      "name": "isubpassInputMS",
      "kind": "vulkan"
    },
    {
      "name": "itexture1D",
      "kind": "vulkan"
    },
    {
      "name": "itexture1DArray",
      "kind": "vulkan"
    },
    {
      "name": "itexture2D",
      "kind": "vulkan"
    },
    {
      "name": "itexture2DArray",
      "kind": "vulkan"
    },
    {
      "name": "itexture2DMS",
      "kind": "vulkan"
    },
    {
      "name": "itexture2DMSArray",
      "kind": "vulkan"
    },
    {
      "name": "itexture2DRect",
      "kind": "vulkan"
    },
    {
      "name": "itexture3D",
      "kind": "vulkan"
    },
    {
      "name": "itextureBuffer",
      "kind": "vulkan"
    },
    {
      "name": "itextureCube",
      "kind": "vulkan"
    },
    {
      "name": "itextureCubeArray",
      "kind": "vulkan"
    },
    {
      "name": "ivec2",
      "kind": "glsl"
    },
    {
      "name": "ivec3",
      "kind": "glsl"
    },
    {
      "name": "ivec4",
      "kind": "glsl"
    },
    {
      "name": "layout",
      "kind": "glsl"
    },
    {
      "name": "long",
      "kind": "reserved"
    },
    {
      "name": "lowp",
      "kind": "glsl"
    },
    {
      "name": "mat2",
      "kind": "glsl"
    },
    {
      "name": "mat2x2",
      "kind": "glsl"
    },
    {
      "name": "mat2x3",
      "kind": "glsl"
    },
    {
      "name": "mat2x4",
      "kind": "glsl"
    },
    {
      "name": "mat3",
      "kind": "glsl"
    },
    {
      "name": "mat3x2",
      "kind": "glsl"
    },
    {
      "name": "mat3x3",
      "kind": "glsl"
    },
    {
      "name": "mat3x4",
      "kind": "glsl"
    },
    {
      "name": "mat4",
      "kind": "glsl"
    },
    {
      "name": "mat4x2",
      "kind": "glsl"
    },
    {
      "name": "mat4x3",
      "kind": "glsl"
    },
    {
      "name": "mat4x4",
      "kind": "glsl"
    },
    {
      "name": "mediump",
      "kind": "glsl"
    },
    {
      "name": "namespace",
      "kind": "reserved"
    },
    {
      "name": "noinline",
      "kind": "reserved"
    },
    {
      "name": "noperspective",
      "kind": "glsl"
    },
    {
      "name": "out",
      "kind": "glsl"
    },
    {
      "name": "output",
      "kind": "reserved"
    },
    {
      "name": "partition",
      "kind": "reserved"
    },
    {
      "name": "patch",
      "kind": "glsl"
    },
    {
      "name": "precise",
      "kind": "glsl"
    },
    {
      "name": "precision",
      "kind": "glsl"
    },
    {
      "name": "public",
      "kind": "reserved"
    },
    {
      "name": "readonly",
      "kind": "glsl"
    },
    {
      "name": "resource",
      "kind": "reserved"
    },
    {
      "name": "restrict",
      "kind": "glsl"
    },
    {
      "name": "return",
      "kind": "glsl"
    },
    {
      "name": "sample",
      "kind": "glsl"
    },
    {
      "name": "sampler",
      "kind": "vulkan"
    },
    {
      "name": "sampler1D",
      "kind": "glsl"
    },
    {
      "name": "sampler1DArray",
      "kind": "glsl"
    },
    {
      "name": "sampler1DArrayShadow",
      "kind": "glsl"
    },
    {
      "name": "sampler1DShadow",
      "kind": "glsl"
    },
    {
      "name": "sampler2D",
      "kind": "glsl"
    },
    {
      "name": "sampler2DArray",
      "kind": "glsl"
    },
    {
      "name": "sampler2DArrayShadow",
      "kind": "glsl"
    },
    {
      "name": "sampler2DMS",
      "kind": "glsl"
    },
    {
      "name": "sampler2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "sampler2DRect",
      "kind": "glsl"
    },
    {
      "name": "sampler2DRectShadow",
      "kind": "glsl"
    },
    {
      "name": "sampler2DShadow",
      "kind": "glsl"
    },
    {
      "name": "sampler3D",
      "kind": "glsl"
    },
    {
      "name": "sampler3DRect",
      "kind": "reserved"
    },
    {
      "name": "samplerBuffer",
      "kind": "glsl"
    },
    {
      "name": "samplerCube",
      "kind": "glsl"
    },
    {
      "name": "samplerCubeArray",
      "kind": "glsl"
    },
    {
      "name": "samplerCubeArrayShadow",
      "kind": "glsl"
    },
    {
      "name": "samplerCubeShadow",
      "kind": "glsl"
    },
    {
      "name": "samplerShadow",
      "kind": "vulkan"
    },
    {
      "name": "shared",
      "kind": "glsl"
    },
    {
      "name": "short",
      "kind": "reserved"
    },
    {
      "name": "sizeof",
      "kind": "reserved"
    },
    {
      "name": "smooth",
      "kind": "glsl"
    },
    {
      "name": "static",
      "kind": "reserved"
    },
    {
      "name": "struct",
      "kind": "glsl"
    },
    {
      "name": "subpassInput",
      "kind": "vulkan"
    },
    {
      "name": "subpassInputMS",
      "kind": "vulkan"
    },
    {
      "name": "subroutine",
      "kind": "glsl"
    },
    {
      "name": "superp",
      "kind": "reserved"
    },
    {
      "name": "switch",
      "kind": "glsl"
    },
    {
      "name": "template",
      "kind": "reserved"
    },
    {
      "name": "texture1D",
      "kind": "vulkan"
    },
    {
      "name": "texture1DArray",
      "kind": "vulkan"
    },
    {
      "name": "texture2D",
      "kind": "vulkan"
    },
    {
      "name": "texture2DArray",
      "kind": "vulkan"
    },
    {
      "name": "texture2DMS",
      "kind": "vulkan"
    },
    {
      "name": "texture2DMSArray",
      "kind": "vulkan"
    },
    {
      "name": "texture2DRect",
      "kind": "vulkan"
    },
    {
      "name": "texture3D",
      "kind": "vulkan"
    },
    {
      "name": "textureBuffer",
      "kind": "vulkan"
    },
    {
      "name": "textureCube",
      "kind": "vulkan"
    },
    {
      "name": "textureCubeArray",
      "kind": "vulkan"
    },
    {
      "name": "this",
      "kind": "reserved"
    },
    {
      "name": "true",
      "kind": "glsl"
    },
    {
      "name": "typedef",
      "kind": "reserved"
    },
    {
      "name": "uimage1D",
      "kind": "glsl"
    },
    {
      "name": "uimage1DArray",
      "kind": "glsl"
    },
    {
      "name": "uimage2D",
      "kind": "glsl"
    },
    {
      "name": "uimage2DArray",
      "kind": "glsl"
    },
    {
      "name": "uimage2DMS",
      "kind": "glsl"
    },
    {
      "name": "uimage2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "uimage2DRect",
      "kind": "glsl"
    },
    {
      "name": "uimage3D",
      "kind": "glsl"
    },
    {
      "name": "uimageBuffer",
      "kind": "glsl"
    },
    {
      "name": "uimageCube",
      "kind": "glsl"
    },
    {
      "name": "uimageCubeArray",
      "kind": "glsl"
    },
    {
      "name": "uint",
      "kind": "glsl"
    },
    {
      "name": "uniform",
      "kind": "glsl"
    },
    {
      "name": "union",
      "kind": "reserved"
    },
    {
      "name": "unsigned",
      "kind": "reserved"
    },
    {
      "name": "usampler1D",
      "kind": "glsl"
    },
    {
      "name": "usampler1DArray",
      "kind": "glsl"
    },
    {
      "name": "usampler2D",
      "kind": "glsl"
    },
    {
      "name": "usampler2DArray",
      "kind": "glsl"
    },
    {
      "name": "usampler2DMS",
      "kind": "glsl"
    },
    {
      "name": "usampler2DMSArray",
      "kind": "glsl"
    },
    {
      "name": "usampler2DRect",
      "kind": "glsl"
    },
    {
      "name": "usampler3D",
      "kind": "glsl"
    },
    {
      "name": "usamplerBuffer",
      "kind": "glsl"
    },
    {
      "name": "usamplerCube",
      "kind": "glsl"
    },
    {
      "name": "usamplerCubeArray",
      "kind": "glsl"
    },
    {
      "name": "using",
      "kind": "reserved"
    },
    {
      "name": "usubpassInput",
      "kind": "vulkan"
    },
    {
      "name": "usubpassInputMS",
      "kind": "vulkan"
    },
    {
      "name": "utexture1D",
      "kind": "vulkan"
    },
    {
      "name": "utexture1DArray",
      "kind": "vulkan"
    },
    {
      "name": "utexture2D",
      "kind": "vulkan"
    },
    {
      "name": "utexture2DArray",
      "kind": "vulkan"
    },
    {
      "name": "utexture2DMS",
      "kind": "vulkan"
    },
    {
      "name": "utexture2DMSArray",
      "kind": "vulkan"
    },
    {
      "name": "utexture2DRect",
      "kind": "vulkan"
    },
    {
      "name": "utexture3D",
      "kind": "vulkan"
    },
    {
      "name": "utextureBuffer",
      "kind": "vulkan"
    },
    {
      "name": "utextureCube",
      "kind": "vulkan"
    },
    {
      "name": "utextureCubeArray",
      "kind": "vulkan"
    },
    {
      "name": "uvec2",
      "kind": "glsl"
    },
    {
      "name": "uvec3",
      "kind": "glsl"
    },
    {
      "name": "uvec4",
      "kind": "glsl"
    },
    {
      "name": "varying",
      "kind": "glsl"
    },
    {
      "name": "vec2",
      "kind": "glsl"
    },
    {
      "name": "vec3",
      "kind": "glsl"
    },
    {
      "name": "vec4",
      "kind": "glsl"
    },
    {
      "name": "void",
      "kind": "glsl"
    },
    {
      "name": "volatile",
      "kind": "glsl"
    },
    {
      "name": "while",
      "kind": "glsl"
    },
    {
      "name": "writeonly",
      "kind": "glsl"
    }
  ],
  "operators": [
    {
      "name": "!",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    },
    {
      "name": "!=",
      "precedence": 8,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "%",
      "precedence": 4,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "%=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "&",
      "precedence": 9,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "&&",
      "precedence": 12,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "&=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "*",
      "precedence": 4,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "*=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "+",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    },
    {
      "name": "+",
      "precedence": 5,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "++",
      "precedence": 2,
      "left_to_right": true,
      "kind": "postfix"
    },
    {
      "name": "++",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    },
    {
      "name": "+=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "-",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    },
    {
      "name": "-",
      "precedence": 5,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "--",
      "precedence": 2,
      "left_to_right": true,
      "kind": "postfix"
    },
    {
      "name": "--",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    },
    {
      "name": "-=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "/",
      "precedence": 4,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "/=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": ":",
      "precedence": 15,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "<",
      "precedence": 7,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "<<",
      "precedence": 6,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "<<=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "<=",
      "precedence": 7,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "==",
      "precedence": 8,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": ">",
      "precedence": 7,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": ">=",
      "precedence": 7,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": ">>",
      "precedence": 6,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": ">>=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "?",
      "precedence": 15,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "^",
      "precedence": 10,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "^=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "^^",
      "precedence": 13,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "|",
      "precedence": 11,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "|=",
      "precedence": 16,
      "left_to_right": false,
      "kind": "infix"
    },
    {
      "name": "||",
      "precedence": 14,
      "left_to_right": true,
      "kind": "infix"
    },
    {
      "name": "~",
      "precedence": 3,
      "left_to_right": false,
      "kind": "prefix"
    }
  ],
  "types": [
    {
      "name": "atomic_uint",
      "description": [
        "a handle for accessing an unsigned integer atomic counter"
      ]
    },
    {
      "name": "bool",
      "description": [
        "a conditional type, taking on values of true or false"
      ]
    },
    {
      "name": "bvec2",
      "description": [
        "a two-component Boolean vector"
      ]
    },
    {
      "name": "bvec3",
      "description": [
        "a three-component Boolean vector"
      ]
    },
    {
      "name": "bvec4",
      "description": [
        "a four-component Boolean vector"
      ]
    },
    {
      "name": "dmat2",
      "description": [
        "a 2 × 2 double-precision floating-point matrix"
      ]
    },
    {
      "name": "dmat2x2",
      "description": [
        "same as a dmat2"
      ]
    },
    {
      "name": "dmat2x3",
      "description": [
        "a double-precision floating-point matrix with 2 columns and 3 rows"
      ]
    },
    {
      "name": "dmat2x4",
      "description": [
        "a double-precision floating-point matrix with 2 columns and 4 rows"
      ]
    },
    {
      "name": "dmat3",
      "description": [
        "a 3 × 3 double-precision floating-point matrix"
      ]
    },
    {
      "name": "dmat3x2",
      "description": [
        "a double-precision floating-point matrix with 3 columns and 2 rows"
      ]
    },
    {
      "name": "dmat3x3",
      "description": [
        "same as a dmat3"
      ]
    },
    {
      "name": "dmat3x4",
      "description": [
        "a double-precision floating-point matrix with 3 columns and 4 rows"
      ]
    },
    {
      "name": "dmat4",
      "description": [
        "a 4 × 4 double-precision floating-point matrix"
      ]
    },
    {
      "name": "dmat4x2",
      "description": [
        "a double-precision floating-point matrix with 4 columns and 2 rows"
      ]
    },
    {
      "name": "dmat4x3",
      "description": [
        "a double-precision floating-point matrix with 4 columns and 3 rows"
      ]
    },
    {
      "name": "dmat4x4",
      "description": [
        "same as a dmat4"
      ]
    },
    {
      "name": "double",
      "description": [
        "a double-precision floating-point scalar"
      ]
    },
    {
      "name": "dvec2",
      "description": [
        "a two-component double-precision floating-point vector"
      ]
    },
    {
      "name": "dvec3",
      "description": [
        "a three-component double-precision floating-point vector"
      ]
    },
    {
      "name": "dvec4",
      "description": [
        "a four-component double-precision floating-point vector"
      ]
    },
    {
      "name": "float",
      "description": [
        "a single-precision floating-point scalar"
      ]
    },
    {
      "name": "iimage1D",
      "description": [
        "a handle for accessing an integer 1D texture"
      ]
    },
    {
      "name": "iimage1DArray",
      "description": [
        "a handle for accessing an integer 1D array texture"
      ]
    },
    {
      "name": "iimage2D",
      "description": [
        "a handle for accessing an integer 2D texture"
      ]
    },
    {
      "name": "iimage2DArray",
      "description": [
        "a handle for accessing an integer 2D array texture"
      ]
    },
    {
      "name": "iimage2DMS",
      "description": [
        "a handle for accessing an integer 2D multisample texture"
      ]
    },
    {
      "name": "iimage2DMSArray",
      "description": [
        "a handle for accessing an integer 2D multisample array texture"
      ]
    },
    {
      "name": "iimage2DRect",
      "description": [
        "a handle for accessing an integer 2D rectangle texture"
      ]
    },
    {
      "name": "iimage3D",
      "description": [
        "a handle for accessing an integer 3D texture"
      ]
    },
    {
      "name": "iimageBuffer",
      "description": [
        "a handle for accessing an integer buffer texture"
      ]
    },
    {
      "name": "iimageCube",
      "description": [
        "a handle for accessing an integer cube mapped texture"
      ]
    },
    {
      "name": "iimageCubeArray",
      "description": [
        "a handle for accessing an integer cube map array texture"
      ]
    },
    {
      "name": "image1D",
      "description": [
        "a handle for accessing a 1D texture"
      ]
    },
    {
      "name": "image1DArray",
      "description": [
        "a handle for accessing a 1D array texture"
      ]
    },
    {
      "name": "image2D",
      "description": [
        "a handle for accessing a 2D texture"
      ]
    },
    {
      "name": "image2DArray",
      "description": [
        "a handle for accessing a 2D array texture"
      ]
    },
    {
      "name": "image2DMS",
      "description": [
        "a handle for accessing a 2D multisample texture"
      ]
    },
    {
      "name": "image2DMSArray",
      "description": [
        "a handle for accessing a 2D multisample array texture"
      ]
    },
    {
      "name": "image2DRect",
      "description": [
        "a handle for accessing a rectangle texture"
      ]
    },
    {
      "name": "image3D",
      "description": [
        "a handle for accessing a 3D texture"
      ]
    },
    {
      "name": "imageBuffer",
      "description": [
        "a handle for accessing a buffer texture"
      ]
    },
    {
      "name": "imageCube",
      "description": [
        "a handle for accessing a cube mapped texture"
      ]
    },
    {
      "name": "imageCubeArray",
      "description": [
        "a handle for accessing a cube map array texture"
      ]
    },
    {
      "name": "int",
      "description": [
        "a signed integer"
      ]
    },
    {
      "name": "isampler1D",
      "description": [
        "a handle for accessing an integer 1D texture"
      ]
    },
    {
      "name": "isampler1DArray",
      "description": [
        "a handle for accessing an integer 1D array texture"
      ]
    },
    {
      "name": "isampler2D",
      "description": [
        "a handle for accessing an integer 2D texture"
      ]
    },
    {
      "name": "isampler2DArray",
      "description": [
        "a handle for accessing an integer 2D array texture"
      ]
    },
    {
      "name": "isampler2DMS",
      "description": [
        "a handle for accessing an integer 2D multisample texture"
      ]
    },
    {
      "name": "isampler2DMSArray",
      "description": [
        "a handle for accessing an integer 2D multisample array texture"
      ]
    },
    {
      "name": "isampler2DRect",
      "description": [
        "a handle for accessing an integer 2D rectangle texture"
      ]
    },
    {
      "name": "isampler3D",
      "description": [
        "a handle for accessing an integer 3D texture"
      ]
    },
    {
      "name": "isamplerBuffer",
      "description": [
        "a handle for accessing an integer buffer texture"
      ]
    },
    {
      "name": "isamplerCube",
      "description": [
        "a handle for accessing an integer cube mapped texture"
      ]
    },
    {
      "name": "isamplerCubeArray",
      "description": [
        "a handle for accessing an integer cube map array texture"
      ]
    },
    {
      "name": "isubpassInput",
      "description": [
        "a handle for accessing an integer subpass input"
      ]
    },
    {
      "name": "isubpassInputMS",
      "description": [
        "a handle for accessing a multi-sampled integer subpass input"
      ]
    },
    {
      "name": "itexture1D",
      "description": [
        "a handle for accessing an integer 1D texture"
      ]
    },
    {
      "name": "itexture1DArray",
      "description": [
        "a handle for accessing an integer 1D array texture"
      ]
    },
    {
      "name": "itexture2D",
      "description": [
        "a handle for accessing an integer 2D texture"
      ]
    },
    {
      "name": "itexture2DArray",
      "description": [
        "a handle for accessing an integer 2D array texture"
      ]
    },
    {
      "name": "itexture2DMS",
      "description": [
        "a handle for accessing an integer 2D multisample texture"
      ]
    },
    {
      "name": "itexture2DMSArray",
      "description": [
        "a handle for accessing an integer 2D multisample array texture"
      ]
    },
    {
      "name": "itexture2DRect",
      "description": [
        "a handle for accessing an integer 2D rectangle texture"
      ]
    },
    {
      "name": "itexture3D",
      "description": [
        "a handle for accessing an integer 3D texture"
      ]
    },
    {
      "name": "itextureBuffer",
      "description": [
        "a handle for accessing an integer buffer texture"
      ]
    },
    {
      "name": "itextureCube",
      "description": [
        "a handle for accessing an integer cube mapped texture"
      ]
    },
    {
      "name": "itextureCubeArray",
      "description": [
        "a handle for accessing an integer cube map array texture"
      ]
    },
    {
      "name": "ivec2",
      "description": [
        "a two-component signed integer vector"
      ]
    },
    {
      "name": "ivec3",
      "description": [
        "a three-component signed integer vector"
      ]
    },
    {
      "name": "ivec4",
      "description": [
        "a four-component signed integer vector"
      ]
    },
    {
      "name": "mat2",
      "description": [
        "a 2 × 2 single-precision floating-point matrix"
      ]
    },
    {
      "name": "mat2x2",
      "description": [
        "same as a mat2"
      ]
    },
    {
      "name": "mat2x3",
      "description": [
        "a single-precision floating-point matrix with 2 columns and 3 rows"
      ]
    },
    {
      "name": "mat2x4",
      "description": [
        "a single-precision floating-point matrix with 2 columns and 4 rows"
      ]
    },
    {
      "name": "mat3",
      "description": [
        "a 3 × 3 single-precision floating-point matrix"
      ]
    },
    {
      "name": "mat3x2",
      "description": [
        "a single-precision floating-point matrix with 3 columns and 2 rows"
      ]
    },
    {
      "name": "mat3x3",
      "description": [
        "same as a mat3"
      ]
    },
    {
      "name": "mat3x4",
      "description": [
        "a single-precision floating-point matrix with 3 columns and 4 rows"
      ]
    },
    {
      "name": "mat4",
      "description": [
        "a 4 × 4 single-precision floating-point matrix"
      ]
    },
    {
      "name": "mat4x2",
      "description": [
        "a single-precision floating-point matrix with 4 columns and 2 rows"
      ]
    },
    {
      "name": "mat4x3",
      "description": [
        "a single-precision floating-point matrix with 4 columns and 3 rows"
      ]
    },
    {
      "name": "mat4x4",
      "description": [
        "same as a mat4"
      ]
    },
    {
      "name": "sampler",
      "description": [
        "a handle for accessing state describing how to sample a texture"
      ]
    },
    {
      "name": "sampler1D",
      "description": [
        "a handle for accessing a 1D texture"
      ]
    },
    {
      "name": "sampler1DArray",
      "description": [
        "a handle for accessing a 1D array texture"
      ]
    },
    {
      "name": "sampler1DArrayShadow",
      "description": [
        "a handle for accessing a 1D array depth texture with comparison"
      ]
    },
    {
      "name": "sampler1DShadow",
      "description": [
        "a handle for accessing a 1D depth texture with comparison"
      ]
    },
    {
      "name": "sampler2D",
      "description": [
        "a handle for accessing a 2D texture"
      ]
    },
    {
      "name": "sampler2DArray",
      "description": [
        "a handle for accessing a 2D array texture"
      ]
    },
    {
      "name": "sampler2DArrayShadow",
      "description": [
        "a handle for accessing a 2D array depth texture with comparison"
      ]
    },
    {
      "name": "sampler2DMS",
      "description": [
        "a handle for accessing a 2D multisample texture"
      ]
    },
    {
      "name": "sampler2DMSArray",
      "description": [
        "a handle for accessing a 2D multisample array texture"
      ]
    },
    {
      "name": "sampler2DRect",
      "description": [
        "a handle for accessing a rectangle texture"
      ]
    },
    {
      "name": "sampler2DRectShadow",
      "description": [
        "a handle for accessing a rectangle texture with comparison"
      ]
    },
    {
      "name": "sampler2DShadow",
      "description": [
        "a handle for accessing a 2D depth texture with comparison"
      ]
    },
    {
      "name": "sampler3D",
      "description": [
        "a handle for accessing a 3D texture"
      ]
    },
    {
      "name": "samplerBuffer",
      "description": [
        "a handle for accessing a buffer texture"
      ]
    },
    {
      "name": "samplerCube",
      "description": [
        "a handle for accessing a cube mapped texture"
      ]
    },
    {
      "name": "samplerCubeArray",
      "description": [
        "a handle for accessing a cube map array texture"
      ]
    },
    {
      "name": "samplerCubeArrayShadow",
      "description": [
        "a handle for accessing a cube map array depth texture with comparison"
      ]
    },
    {
      "name": "samplerCubeShadow",
      "description": [
        "a handle for accessing a cube map depth texture with comparison"
      ]
    },
    {
      "name": "samplerShadow",
      "description": [
        "a handle for accessing state describing how to sample a depth texture with comparison"
      ]
    },
    {
      "name": "subpassInput",
      "description": [
        "a handle for accessing a floating-point subpass input"
      ]
    },
    {
      "name": "subpassInputMS",
      "description": [
        "a handle for accessing a multi-sampled floating-point subpass input"
      ]
    },
    {
      "name": "texture1D",
      "description": [
        "a handle for accessing a 1D texture"
      ]
    },
    {
      "name": "texture1DArray",
      "description": [
        "a handle for accessing a 1D array texture"
      ]
    },
    {
      "name": "texture2D",
      "description": [
        "a handle for accessing a 2D texture"
      ]
    },
    {
      "name": "texture2DArray",
      "description": [
        "a handle for accessing a 2D array texture"
      ]
    },
    {
      "name": "texture2DMS",
      "description": [
        "a handle for accessing a 2D multisample texture"
      ]
    },
    {
      "name": "texture2DMSArray",
      "description": [
        "a handle for accessing a 2D multisample array texture"
      ]
    },
    {
      "name": "texture2DRect",
      "description": [
        "a handle for accessing a rectangle texture"
      ]
    },
    {
      "name": "texture3D",
      "description": [
        "a handle for accessing a 3D texture"
      ]
    },
    {
      "name": "textureBuffer",
      "description": [
        "a handle for accessing a buffer texture"
      ]
    },
    {
      "name": "textureCube",
      "description": [
        "a handle for accessing a cube mapped texture"
      ]
    },
    {
      "name": "textureCubeArray",
      "description": [
        "a handle for accessing a cube map array texture"
      ]
    },
    {
      "name": "uimage1D",
      "description": [
        "a handle for accessing an unsigned integer 1D texture"
      ]
    },
    {
      "name": "uimage1DArray",
      "description": [
        "a handle for accessing an unsigned integer 1D array texture"
      ]
    },
    {
      "name": "uimage2D",
      "description": [
        "a handle for accessing an unsigned integer 2D texture"
      ]
    },
    {
      "name": "uimage2DArray",
      "description": [
        "a handle for accessing an unsigned integer 2D array texture"
      ]
    },
    {
      "name": "uimage2DMS",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample texture"
      ]
    },
    {
      "name": "uimage2DMSArray",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample array texture"
      ]
    },
    {
      "name": "uimage2DRect",
      "description": [
        "a handle for accessing an unsigned integer rectangle texture"
      ]
    },
    {
      "name": "uimage3D",
      "description": [
        "a handle for accessing an unsigned integer 3D texture"
      ]
    },
    {
      "name": "uimageBuffer",
      "description": [
        "a handle for accessing an unsigned integer buffer texture"
      ]
    },
    {
      "name": "uimageCube",
      "description": [
        "a handle for accessing an unsigned integer cube mapped texture"
      ]
    },
    {
      "name": "uimageCubeArray",
      "description": [
        "a handle for accessing an unsigned integer cube map array texture"
      ]
    },
    {
      "name": "uint",
      "description": [
        "an unsigned integer"
      ]
    },
    {
      "name": "usampler1D",
      "description": [
        "a handle for accessing an unsigned integer 1D texture"
      ]
    },
    {
      "name": "usampler1DArray",
      "description": [
        "a handle for accessing an unsigned integer 1D array texture"
      ]
    },
    {
      "name": "usampler2D",
      "description": [
        "a handle for accessing an unsigned integer 2D texture"
      ]
    },
    {
      "name": "usampler2DArray",
      "description": [
        "a handle for accessing an unsigned integer 2D array texture"
      ]
    },
    {
      "name": "usampler2DMS",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample texture"
      ]
    },
    {
      "name": "usampler2DMSArray",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample array texture"
      ]
    },
    {
      "name": "usampler2DRect",
      "description": [
        "a handle for accessing an unsigned integer rectangle texture"
      ]
    },
    {
      "name": "usampler3D",
      "description": [
        "a handle for accessing an unsigned integer 3D texture"
      ]
    },
    {
      "name": "usamplerBuffer",
      "description": [
        "a handle for accessing an unsigned integer buffer texture"
      ]
    },
    {
      "name": "usamplerCube",
      "description": [
        "a handle for accessing an unsigned integer cube mapped texture"
      ]
    },
    {
      "name": "usamplerCubeArray",
      "description": [
        "a handle for accessing an unsigned integer cube map array texture"
      ]
    },
    {
      "name": "usubpassInput",
      "description": [
        "a handle for accessing an unsigned-integer subpass input"
      ]
    },
    {
      "name": "usubpassInputMS",
      "description": [
        "a handle for accessing a multi-sampled unsigned-integer subpass input"
      ]
    },
    {
      "name": "utexture1D",
      "description": [
        "a handle for accessing an unsigned integer 1D texture"
      ]
    },
    {
      "name": "utexture1DArray",
      "description": [
        "a handle for accessing an unsigned integer 1D array texture"
      ]
    },
    {
      "name": "utexture1DArray",
      "description": [
        "a handle for accessing an unsigned integer 2D array texture"
      ]
    },
    {
      "name": "utexture2D",
      "description": [
        "a handle for accessing an unsigned integer 2D texture"
      ]
    },
    {
      "name": "utexture2DMS",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample texture"
      ]
    },
    {
      "name": "utexture2DMSArray",
      "description": [
        "a handle for accessing an unsigned integer 2D multisample array texture"
      ]
    },
    {
      "name": "utexture2DRect",
      "description": [
        "a handle for accessing an unsigned integer rectangle texture"
      ]
    },
    {
      "name": "utexture3D",
      "description": [
        "a handle for accessing an unsigned integer 3D texture"
      ]
    },
    {
      "name": "utextureBuffer",
      "description": [
        "a handle for accessing an unsigned integer buffer texture"
      ]
    },
    {
      "name": "utextureCube",
      "description": [
        "a handle for accessing an unsigned integer cube mapped texture"
      ]
    },
    {
      "name": "utextureCubeArray",
      "description": [
        "a handle for accessing an unsigned integer cube map array texture"
      ]
    },
    {
      "name": "uvec2",
      "description": [
        "a two-component unsigned integer vector"
      ]
    },
    {
      "name": "uvec3",
      "description": [
        "a three-component unsigned integer vector"
      ]
    },
    {
      "name": "uvec4",
      "description": [
        "a four-component unsigned integer vector"
      ]
    },
    {
      "name": "vec2",
      "description": [
        "a two-component single-precision floating-point vector"
      ]
    },
    {
      "name": "vec3",
      "description": [
        "a three-component single-precision floating-point vector"
      ]
    },
    {
      "name": "vec4",
      "description": [
        "a four-component single-precision floating-point vector"
      ]
    },
    {
      "name": "void",
      "description": [
        "for functions that do not return a value"
      ]
    }
  ],
  "variables": [
    {
      "description": [
        "Value: mat4(vec4(0.00390625, 0.0, 0.0, 0.0), vec4(0.0, 0.00390625, 0.0, 0.0), vec4(0.0, 0.0, 0.00390625, 0.0), vec4(0.03125, 0.03125, 0.03125, 1.0))"
      ],
      "extensions": [],
      "modifiers": "const",
      "name": "TEXTURE_MATRIX_2",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "alpha test reference value, the check is \"if (color.a < alphaTestRef) discard;\""
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "alphaTestRef",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The ambient light value of the current dimension.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "ambientLight",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "viewWidth / viewHeight"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "aspectRatio",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "offset to block center in 1/64m units       Only for blocks"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "at_midBlock",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "xyz = tangent vector, w = handedness"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "at_tangent",
      "type": "vec4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "vertex offset to previous frame In view space, only for entities and block entities"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "at_velocity",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "texture atlas size (only set when the atlas texture is bound)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "atlasSize",
      "type": "ivec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The minimum height of the current dimension.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "bedrockLevel",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Identifies the biome currently occupied by the player. Can be compared with predefined constants like BIOME_PLAINS, BIOME_RIVER, etc.",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "biome",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Identifies the biome category currently occupied by the player. Can be compared with predefined constants like CAT_NONE, CAT_TAIGA, etc.",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "biome_category",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Tells what type of precipitation occurs in this biome. 0 is no precipitation (PPT_NONE), 1 is rain (PPT_RAIN), 2 is snow (PPT_SNOW).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "biome_precipitation",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "blend function (srcRGB, dstRGB, srcAlpha, dstAlpha)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "blendFunc",
      "type": "ivec4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "blindness (0.0-1.0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "blindness",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "block entity ID (block ID for the tile entity, only for blocks specified in \"block.properties\")"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "blockEntityId",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "1 = custom, 2 = ender dragon, 3 = wither, 4 = raid"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "bossBattle",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "camera position in world space"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "cameraPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "centerDepth smoothed with centerDepthSmoothHalflife"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "centerDepthSmooth",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The height of vanilla clouds in the current dimension in blocks. Value is NaN for dimensions without clouds.",
        "Added in Iris 1.6.9"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "cloudHeight",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex0",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "1"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex1",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "18 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex10",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "19 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex11",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "20 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex12",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "21 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex13",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "22 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex14",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "23 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex15",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "2"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex2",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "3"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex3",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "7  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex4",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "8  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex5",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "9  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex6",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "10 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex7",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "16 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex8",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "17 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "colortex9",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "3"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "composite",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The color space used when displaying to the screen. 0 is sRGB, 1 is DCI_P3, 2 is Display P3, 3 is REC2020, 4 is Adobe RGB.",
        "Added in Iris 1.6.4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentColorSpace",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "OS reported date in the format: ivec3(year, month, day).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentDate",
      "type": "ivec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Current player air from 0-1. Multiply by maxPlayerAir to get the actual value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentPlayerAir",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Current player armor from 0-1. Multiply by maxPlayerArmor to get the actual value.",
        "Added in Iris 1.6.15"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentPlayerArmor",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Current player health from 0-1. Multiply by maxPlayerHealth to get the actual value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentPlayerHealth",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Current player hunger from 0-1. Multiply by maxPlayerHunger to get the actual value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentPlayerHunger",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "OS reported time in the format: ivec3(hour, minute, second).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentTime",
      "type": "ivec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "OS reported year time in the format: ivec2(seconds_ellapsed_in_year, seconds_remaining_in_year).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "currentYearTime",
      "type": "ivec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "strength of the darkness effect (0.0-1.0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "darknessFactor",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "lightmap variations caused by the darkness effect (0.0-1.0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "darknessLightFactor",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "6"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "depthtex0",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "depthtex1",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "12"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "depthtex2",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "entity color multiplier (entity hurt, creeper flashing when exploding)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "entityColor",
      "type": "vec4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "entity ID"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "entityId",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Controls the bounds for entity shadows to be rendered. By default, it is the value set for terrain.",
        "Any floating point number that is not 1 is multiplied by the terrain distance to get the final shadow distance multiplier.",
        "Added in Iris 1.2.1"
      ],
      "extensions": [],
      "modifiers": "const",
      "name": "entityShadowDistanceMul",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "view entity Y position"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "eyeAltitude",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "x = block brightness, y = sky brightness, light 0-15 = brightness 0-240"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "eyeBrightness",
      "type": "ivec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "eyeBrightness smoothed with eyeBrightnessHalflife"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "eyeBrightnessSmooth",
      "type": "ivec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "World space position of the player's head model. When in first person view, this is equivalent to cameraPosition. In third person mode the two will differ.",
        "Added in Iris 1.4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "eyePosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "far viewing plane distance"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "far",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when in first-person view.",
        "Added in Iris 1.4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "firstPersonCamera",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "r, g, b"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogColor",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0.0-1.0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogDensity",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "fog end distance (m)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogEnd",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "GL_LINEAR, GL_EXP or GL_EXP2"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogMode",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0 = sphere, 1 = cylinder"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogShape",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "fog start distance (m)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "fogStart",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Frame index (0 to 720719, then resets to 0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "frameCounter",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "last frame time, seconds"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "frameTime",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "run time, seconds (resets to 0 after 3600s)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "frameTimeCounter",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "7  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gaux1",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "8  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gaux2",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "9  <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gaux3",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "10 <custom texture or output from deferred programs>"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gaux4",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "modelview matrix after setting up the camera transformations"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferModelView",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse gbufferModelView"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferModelViewInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "last frame gbufferModelView"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferPreviousModelView",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "last frame gbufferProjection"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferPreviousProjection",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "projection matrix when the gbuffers were generated"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferProjection",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse gbufferProjection"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gbufferProjectionInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gcolor",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "1"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gdepth",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "6"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gdepthtex",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_BaryCoordEXT",
      "description": [
        "The built-in fragment shader input variables `gl_BaryCoordEXT` and\n`gl_BaryCoordNoPerspEXT` are three-component vectors providing barycentric\ncoordinates for the fragment.  The values for these built-ins are derived\nas described in the OpenGL or Vulkan API Specifications."
      ],
      "extensions": [
        "GL_EXT_fragment_shader_barycentric"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_BaryCoordNV",
      "description": [
        "The built-in fragment shader input variables `gl_BaryCoordNV` and\n`gl_BaryCoordNoPerspNV` are three-component vectors providing barycentric\ncoordinates for the fragment.  The values for these built-ins are derived\nas described in the OpenGL or Vulkan API Specifications."
      ],
      "extensions": [
        "GL_NV_fragment_shader_barycentric"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_BaryCoordNoPerspEXT",
      "description": [
        "`gl_BaryCoordEXT` -> BaryCoordKHR decorated OpVariable\n`gl_BaryCoordNoPerspEXT` -> BaryCoordNoPerspKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_fragment_shader_barycentric"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_BaryCoordNoPerspNV",
      "description": [
        "`gl_BaryCoordNV` -> BaryCoordNV decorated OpVariable\n`gl_BaryCoordNoPerspNV` -> BaryCoordNoPerspNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_fragment_shader_barycentric"
      ]
    },
    {
      "modifiers": "in",
      "type": "float[]",
      "name": "gl_ClipDistance",
      "description": [
        "The `gl_ClipDistance` variable provides a forward compatible mechanism for controlling user clipping. The element _gl_ClipDistance_[_i_] specifies a clip distance for each user clip plane _i_. A distance of 0.0 means that the vertex is on the plane, a positive distance means that the vertex is insider the clip plane, and a negative distance means that the point is outside the clip plane. The clip distances will be linearly interpolated across the primitive and the portion of the primitive with interpolated distances less than 0.0 will be clipped.",
        "The `gl_ClipDistance` array is initially predeclared as unsized and must be sized by the shader either by redeclaring it with an explicit size, or by indexing it with only integral constant expressions. The array must be sized to include all clip planes that are enabled via the OpenGL API; if the size does not include all enabled planes, results are undefined. The size may be at most `gl_MaxClipDistances`. The number of varying components consumed by `gl_ClipDistance` will match the size of the array, no matter how many planes are enabled. The shader must also set all values in `gl_ClipDistance` that have been enabled via the OpenGL API, or results are undefined. Values written into `gl_ClipDistance` planes that are not enabled have no effect.",
        "In the vertex, tessellation evaluation and geometry languages, a single global instance of the `gl_PerVertex` named block is available and its `gl_ClipDistance` member is an output that receives the clip distances for the current vertex. It may be written at any time during shader execution. The value written to `gl_ClipDistance` will be used by primitive assembly, clipping, culling and other fixed functionality operations, if present, that operate on primitives after vertex processing has occurred.",
        "In the tessellation control language, the `gl_PerVertex` named block is used to construct an array, `gl_out[]`, whose `gl_ClipDistance` members hold clip distances for each of the control points, which become available as inputs to the subsequent tessellation evaluation shader.",
        "The value of `gl_ClipDistance` (or the `gl_ClipDistance` member of the `gl_out[]` array, in the case of the tessellation control shader) is undefined after the vertex, tessellation control, and tessellation evaluation shading stages if the corresponding shader executable does not write to gl_ClipDistance. It is also undefined after the geometry processing stage if the geometry shader executable calls EmitVertex without having written `gl_ClipDistance` since the last call to EmitVertex (or hasn't written it at all).",
        "In the tessellation control, tessellation evaluation and geoemetry languages, the `gl_PerVertex` named block is used to construct an array, `gl_in[]` of per-vertex or per-control point inputs whose content represents the corresponding outputs written by the previous stage. Only elements of the `gl_ClipDistance` array that correspond to enabled clip planes have defined values."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_CoreCountARM",
      "description": [
        "`gl_CoreIDARM` -> CoreIDARM decorated OpVariable\n`gl_CoreCountARM` -> CoreCountARM decorated OpVariable\n`gl_CoreMaxIDARM` -> CoreMaxIDARM decorated OpVariable\n`gl_WarpIDARM` -> WarpIDARM decorated OpVariable\n`gl_WarpMaxIDARM` -> WarpMaxIDARM decorated OpVariable"
      ],
      "extensions": [
        "GL_ARM_shader_core_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_CoreIDARM",
      "description": [
        "The variable `gl_CoreIDARM` holds the ID of the shader core the executing\ninvocation is running on.\nThis variable is in the range 0 to `gl_CoreMaxIDARM`."
      ],
      "extensions": [
        "GL_ARM_shader_core_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_CoreMaxIDARM",
      "description": [
        "The variable `gl_CoreMaxIDARM` holds the max ID of any shader core on the\ndevice."
      ],
      "extensions": [
        "GL_ARM_shader_core_builtins"
      ]
    },
    {
      "modifiers": "in",
      "type": "float[]",
      "name": "gl_CullDistance",
      "description": [
        "The `gl_CullDistance` variable provides a mechanism for controlling user culling. The element _gl_CullDistance_[_i_] specifies a cull distance for each plane _i_. A distance of 0.0 means that the vertex is on the plane, a positive distance means that the vertex is inside the cull volume, and a negative distance means that the point is outside the cull volume. Primitives whose vertices all have a negative cull distance for plane _i_ will be discarded.",
        "The `gl_CullDistance` array is predeclared as unsized and must be sized by the shader either by redeclaring it with an size or by indexing it only with integral constant expressions. The size determines the number and set of enabled cull distances and can be at most `gl_MaxCullDistances`. The number of varying components consumed by `gl_CullDistance` will match the size of the array. Shaders writing `gl_CullDistance` must write all enabled distances, or culling results are undefined.",
        "As an output variable, `gl_CullDistance` provides the place for the shader to write these distances. As an input in all but the fragment language, it reads the values written in the previous shader stage. In the fragment language, the `gl_CullDistance` array contains linearly interpolated values for the vertex values written by a shader to the `gl_CullDistance` vertex output variable.",
        "It is a compile-time or link-time error for the set of shaders forming a program to have the sum of the sizes of the `gl_ClipDistance` and `gl_CullDistance` arrays to be larger than `gl_MaxCombinedClipAndCullDistances`."
      ],
      "versions": [
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_CullMaskEXT",
      "extensions": [
        "GL_EXT_ray_cull_mask"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_CurrentRayTimeNV",
      "description": [
        "Add the following description for `gl_CurrentRayTimeNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing_motion_blur"
      ]
    },
    {
      "modifiers": "highp",
      "type": "int",
      "name": "gl_DeviceIndex",
      "description": [
        "Add the following description for `gl_DeviceIndex`:"
      ],
      "extensions": [
        "GL_EXT_device_group"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec4",
      "name": "gl_FragCoord",
      "description": [
        "Available only in the fragment language, `gl_FragCoord` is an input variable that contains the window relative coordinate (x, y, z, 1/w) values for the fragment. If multi-sampling, this value can be for any location within the pixel, or one of the fragment samples. This value is the result of fixed functionality that interpolates primitives after vertex processing to generate fragments. The z component is the depth value that would be used for the fragment's depth if no shader contained any writes to gl_FragDepth.",
        "`gl_FragCoord` may be redeclared with the additional layout qualifier identifiers `origin_upper_left` or `pixel_center_integer`. By default, `gl_FragCoord` assumes a lower-left origin for window coordinates and assumes pixel centers are located at half-pixel centers. For example, the (x, y) location (0.5, 0.5) is returned for the lower-left-most pixel in a window. The origin of `gl_FragCoord` may be changed by redeclaring `gl_FragCoord` with the `origin_upper_left` identifier. The values returned can also be shifted by half a pixel in both x and y by `pixel_center_integer` so it appears the pixels are centered at whole number pixel offsets. This moves the (x, y) value returned by `gl_FragCoord` of (0.5, 0.5) by default to (0.0, 0.0) with `pixel_center_integer`.",
        "If `gl_FragCoord` is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static use of `gl_FragCoord`. Redeclaring `gl_FragCoord` with any accepted qualifier affects only `gl_FragCoord.x` and `gl_FragCoord.y`. It has no affect on rasterization, transformation or any other part of the OpenGL pipline or language features."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "out",
      "type": "float",
      "name": "gl_FragDepth",
      "description": [
        "Available only in the fragment language, `gl_FragDepth` is an output variable that is used to establish the depth value for the current fragment. If depth buffering is enabled and no shader writes to `gl_FragDepth`, then the fixed function value for depth will be used (this value is contained in the z component of gl_FragCoord) otherwise, the value written to `gl_FragDepth` is used. If a shader statically assigns to `gl_FragDepth`, then the value of the fragment's depth may be undefined for executions of the shader that don't take that path. That is, if the set of linked fragment shaders statically contain a write to `gl_FragDepth`, then it is responsible for always writing it."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_FragInvocationCountEXT",
      "description": [
        "The input variable `gl_FragInvocationCountEXT` represents the maximum number\nof fragment shader invocations executed for each fragment, as derived from\nthe effective invocation density for the fragment. The actual number of\nfragment shader invocations for a given fragment may be less than this\nmaximum invocation count. For example, if a primitive does not fully\ncover the fragment, invocations may not be generated for uncovered\nportions of the fragment. When a shading rate image or fragment density\nmap is not used, this value will be no greater than the framebuffer\nsample counts and may be affected by the sample shading fraction\nprogrammed in the OpenGL API via MinSampleShading or the Vulkan API via\nminSampleShading. When using a shading rate image or fragment density map,\nthis value will also be affected by the contents of the texture and may\ndepend on the location of the pixel in the framebuffer. If multisampling\nis disabled, the value of this input will be one."
      ],
      "extensions": [
        "GL_EXT_fragment_invocation_density"
      ]
    },
    {
      "modifiers": "in",
      "type": "ivec2",
      "name": "gl_FragSizeEXT",
      "description": [
        "The input variable `gl_FragSizeEXT` represents the size of a rectangle of\npixels corresponding to this fragment shader invocation.  The first\ncomponent is the width of the rectangle (in pixels); the second component\nis the height (in pixels).  When a shading rate image or fragment density\nmap is not used, both components will be one.  When using a shading\nrate image or fragment density map, either or both components may be\ngreater than one.  When a fragment larger than one pixel is processed by a\nsingle fragment shader invocation, the outputs of the shader invocation\nwill be broadcast to all covered pixels/samples in the fragment.  When a\nfragment larger than one pixel is processed by multiple fragment shader\ninvocations, the outputs of each shader invocation will be a broadcast to\nan implementation-dependent subset of the covered pixels/samples in the\nfragment."
      ],
      "extensions": [
        "GL_EXT_fragment_invocation_density"
      ]
    },
    {
      "modifiers": "in",
      "type": "ivec2",
      "name": "gl_FragmentSizeNV",
      "description": [
        "The input variable `gl_FragmentSizeNV` represents the size of a rectangle of\npixels corresponding to this fragment shader invocation.  The first\ncomponent is the width of the rectangle (in pixels); the second component\nis the height (in pixels).  When a shading rate image is not used, or\nwhen running multiple fragment shader invocations per pixel\n(multisampling), both components will be one.  When using a shading rate\nimage, either or both components may be greater than one.  When the\nfragment size is greater than a single pixel, the outputs of the shader\ninvocation will be broadcast to all covered pixels/samples in the\nrectangle."
      ],
      "extensions": [
        "GL_NV_shading_rate_image"
      ]
    },
    {
      "modifiers": "in",
      "type": "bool",
      "name": "gl_FrontFacing",
      "description": [
        "Available only in the fragment language, `gl_FrontFacing` is an input variable whose value is `true` if the fragment belongs to a front-facing primitive and false otherwise. The determination of whether a triangle primitive is front-facing is made by examining the sign of the area of the triangle, including a possible reversal of this sign as controlled by `glFrontFace`. One way to compute this area is:",
        "` a = 1 / 2 ∑_ j = 0 ^ n - 1 x_w^i y_w^i + 1 - x_w^i + 1 y_w^i `",
        "where ` x_w^i ` and ` y_w^i ` are the x and y window coordinates of the _i_th vertex of the n-vertex polygon.",
        "The sign of this computation is negated when the value of `GL_CLIP_ORIGIN` (the clip volume origin, set with glClipControl) is `GL_UPPER_LEFT`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_GeometryIndexEXT",
      "description": [
        "Add the following description for `gl_GeometryIndexEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_GeometryIndexEXT",
      "description": [
        "Add the following description for `gl_GeometryIndexEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_GlobalInvocationID",
      "description": [
        "In the compute language, `gl_GlobalInvocationID` is a derived input variable containing the n-dimensional index of the work invocation within the global work group that the current shader is executing on. The value of `gl_GlobalInvocationID` is equal to `gl_WorkGroupID` * `gl_WorkGroupSize` + `gl_LocalInvocationID`."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_GlobalInvocationID",
      "description": [
        "The built-in variable `gl_GlobalInvocationID` is a compute, task, or mesh\nshader input variable containing the global index of the current work\nitem. This value uniquely identifies this invocation from all other\ninvocations across all local and global workgroups initiated by the\ncurrent DispatchCompute or DispatchMeshTasksEXT call or by a previously\nexecuted task shader. ..."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_GlobalInvocationID",
      "description": [
        "The built-in variable `gl_GlobalInvocationID` is a compute, task, or mesh\nshader input variable containing the global index of the current work\nitem. This value uniquely identifies this invocation from all other\ninvocations across all local and global work groups initiated by the\ncurrent DispatchCompute or DispatchMeshTasksNV call or by a previously\nexecuted task shader. ..."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "bool",
      "name": "gl_HelperInvocation",
      "description": [
        "The value `gl_HelperInvocation` is true if the fragment shader invocation is considered a helper invocation and is false otherwise. A helper invocation is a fragment-shader invocation that is created solely for the purposes of evaluating derivatives for use in non-helper fragment-shader invocations. Such derivatives are computed implicitly in the built-in function texture(), and explicitly in the derivative functions dFdx() and `dFdy`.",
        "Fragment shader helper invocations execute the same shader code as non-helper invocations, but will not have side effects that modify the framebuffer or other shader-accessible memory. In particular:",
        "Fragments corresponding to helper invocations are discarded when shader execution is complete, without updating the framebuffer.",
        "Stores to image and buffer variables performed by helper invocations have no effect on the underlying image or buffer memory.",
        "Atomic operations to image, buffer, or atomic counter variables performed by helper invocations have no effect on the underlying image or buffer memory. The values returned by such atomic operations are undefined.",
        "",
        "Helper invocations may be generated for pixels not covered by a primitive being rendered. While fragment shader inputs qualified with centroid are normally required to be sampled in the intersection of the pixel and the primitive, the requirement is ignored for such pixels since there is no intersection between the pixel and primitive.",
        "Helper invocations may also be generated for fragments that are covered by a primitive being rendered when the fragment is killed by early fragment tests (using the early_fragment_tests qualifier) or where the implementation is able to determine that executing the fragment shader would have no effect other than assisting in computing derivatives for other fragment shader invocations.",
        "The set of helper invocations generated when processing any set of primitives is implementation dependent."
      ],
      "versions": [
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_HitKindBackFacingMicroTriangleNV",
      "extensions": [
        "GL_NV_displacement_micromap"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_HitKindBackFacingTriangleEXT",
      "default_value": "0xFFU",
      "description": [
        "`gl_HitKindFrontFacingTriangleEXT` -> HitKindFrontFacingTriangleKHR hit kind\n`gl_HitKindBackFacingTriangleEXT` -> HitKindBackFacingTriangleKHR hit kind"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_HitKindEXT",
      "description": [
        "Add the following description for `gl_HitKindEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_HitKindFrontFacingMicroTriangleNV",
      "extensions": [
        "GL_NV_displacement_micromap"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_HitKindFrontFacingTriangleEXT",
      "default_value": "0xFEU",
      "description": [
        "const uint `gl_HitKindFrontFacingTriangleEXT` = 0xFEU;\nconst uint `gl_HitKindBackFacingTriangleEXT` = 0xFFU;"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_HitKindNV",
      "description": [
        "Add the following description for `gl_HitKindNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_HitTEXT",
      "description": [
        "Add the following description for `gl_HitTEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_HitTNV",
      "description": [
        "Add the following description for `gl_HitTNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsEXT",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsEXT",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsEXT",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsNV",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsNV",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_IncomingRayFlagsNV",
      "description": [
        "Add the following description for `gl_IncomingRayFlagsNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceCustomIndexEXT",
      "description": [
        "Add the following description for `gl_InstanceCustomIndexEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceCustomIndexEXT",
      "description": [
        "Add the following description for `gl_InstanceCustomIndexEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceCustomIndexNV",
      "description": [
        "Add the following description for `gl_InstanceCustomIndexNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceCustomIndexNV",
      "description": [
        "Add the following description for `gl_InstanceCustomIndexNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceID",
      "description": [
        "`gl_InstanceID` is a vertex language input variable that holds the integer index of the current primitive in an instanced draw command such as `glDrawArraysInstanced`. If the current primitive does not originate from an instanced draw command, the value of `gl_InstanceID` is zero."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceID",
      "description": [
        "Add the following description for `gl_InstanceID`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceID",
      "description": [
        "Add the following description for `gl_InstanceID`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceID",
      "description": [
        "Add the following description for `gl_InstanceID`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceID",
      "description": [
        "Add the following description for `gl_InstanceID`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "description": [
        "The variable `gl_InstanceIndex` is a vertex language input variable that holds the instance number of the current primitive in an instanced draw call, relative to a base. If the current primitive does not come from an instanced draw call, the value of `gl_InstanceIndex` is zero."
      ],
      "modifiers": "in",
      "name": "gl_InstanceIndex",
      "type": "int",
      "versions": [
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InstanceIndex",
      "description": [
        "The variable `gl_InstanceIndex` is a vertex language input variable that holds the instance number of the current primitive in an instanced draw call, relative to a base. If the current primitive does not come from an instanced draw call, the value of `gl_InstanceIndex` is zero."
      ],
      "versions": [
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InvocationID",
      "description": [
        "In the tessellation control language, `gl_InvocationID` contains the index of the output patch vertex assigned to the shader invocation. It is assigned an integer value in the range [0, N-1] where N is the number of output patch vertices.",
        "In the geometry language, `gl_InvocationID` identifies the invocation number assigned to the geometry shader invocation. It is assigned an integer value in the range [0, N-1] where N is the number of geometry shader invocations per primitive."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_InvocationsPerPixelNV",
      "description": [
        "The input variable `gl_InvocationsPerPixelNV` represents the maximum number\nof fragment shader invocations executed for each pixel, as derived from\nthe effective shading rate for the fragment.  If a primitive does not\nfully cover a pixel, the number of fragment shader invocations for its\ncovered pixels may be less than the value of `gl_InvocationsPerPixelNV`.\nWhen a shading rate image is not used, this value is a function of the\nframebuffer sample counts and the sample shading fraction programmed in\nthe OpenGL API via MinSampleShading.  When using the shading rate image,\nthis value will also be affected by the contents of the shading rate image\nand may depend on the location of the pixel in the framebuffer.  If\nmultisampling is disabled, or if the fragment shader invocation covers\nmultiple pixels, the value of this input will be one."
      ],
      "extensions": [
        "GL_NV_shading_rate_image"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDEXT",
      "description": [
        "Add the following description for `gl_LaunchIDEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDEXT",
      "description": [
        "Add the following description for `gl_LaunchIDEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDEXT",
      "description": [
        "Add the following description for `gl_LaunchIDEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDEXT",
      "description": [
        "Add the following description for `gl_LaunchIDEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDEXT",
      "description": [
        "Add the following description for `gl_LaunchIDEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDNV",
      "description": [
        "Add the following description for `gl_LaunchIDNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDNV",
      "description": [
        "Add the following description for `gl_LaunchIDNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDNV",
      "description": [
        "Add the following description for `gl_LaunchIDNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDNV",
      "description": [
        "Add the following description for `gl_LaunchIDNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchIDNV",
      "description": [
        "Add the following description for `gl_LaunchIDNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeEXT",
      "description": [
        "`gl_LaunchIDEXT` -> LaunchIdKHR decorated OpVariable\n`gl_LaunchSizeEXT` -> LaunchSizeKHR decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexEXT` -> InstanceCustomIndexKHR decorated OpVariable\n`gl_GeometryIndexEXT` -> RayGeometryIndexKHR decorated OpVariable\n`gl_WorldRayOriginEXT` -> WorldRayOriginKHR decorated OpVariable\n`gl_WorldRayDirectionEXT` -> WorldRayDirectionKHR decorated OpVariable\n`gl_ObjectRayOriginEXT` -> ObjectRayOriginKHR decorated OpVariable\n`gl_ObjectRayDirectionEXT` -> ObjectRayDirectionKHR decorated OpVariable\n`gl_RayTminEXT` -> RayTminKHR decorated OpVariable\n`gl_RayTmaxEXT` -> RayTmaxKHR decorated OpVariable\n`gl_IncomingRayFlagsEXT` -> IncomingRayFlagsKHR decorated OpVariable\n`gl_HitTEXT` -> RayTmaxKHR decorated OpVariable\n`gl_HitKindEXT` -> HitKindKHR decorated OpVariable\n`gl_ObjectToWorldEXT` -> ObjectToWorldKHR decorated OpVariable\n`gl_WorldToObjectEXT` -> WorldToObjectKHR decorated OpVariable\n`gl_WorldToObject3x4EXT` -> Transpose of WorldToObjectKHR decorated OpVariable\n`gl_ObjectToWorld3x4EXT` -> Transpose of ObjectToWorldKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeEXT",
      "description": [
        "`gl_LaunchIDEXT` -> LaunchIdKHR decorated OpVariable\n`gl_LaunchSizeEXT` -> LaunchSizeKHR decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexEXT` -> InstanceCustomIndexKHR decorated OpVariable\n`gl_GeometryIndexEXT` -> RayGeometryIndexKHR decorated OpVariable\n`gl_WorldRayOriginEXT` -> WorldRayOriginKHR decorated OpVariable\n`gl_WorldRayDirectionEXT` -> WorldRayDirectionKHR decorated OpVariable\n`gl_ObjectRayOriginEXT` -> ObjectRayOriginKHR decorated OpVariable\n`gl_ObjectRayDirectionEXT` -> ObjectRayDirectionKHR decorated OpVariable\n`gl_RayTminEXT` -> RayTminKHR decorated OpVariable\n`gl_RayTmaxEXT` -> RayTmaxKHR decorated OpVariable\n`gl_IncomingRayFlagsEXT` -> IncomingRayFlagsKHR decorated OpVariable\n`gl_HitTEXT` -> RayTmaxKHR decorated OpVariable\n`gl_HitKindEXT` -> HitKindKHR decorated OpVariable\n`gl_ObjectToWorldEXT` -> ObjectToWorldKHR decorated OpVariable\n`gl_WorldToObjectEXT` -> WorldToObjectKHR decorated OpVariable\n`gl_WorldToObject3x4EXT` -> Transpose of WorldToObjectKHR decorated OpVariable\n`gl_ObjectToWorld3x4EXT` -> Transpose of ObjectToWorldKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeEXT",
      "description": [
        "`gl_LaunchIDEXT` -> LaunchIdKHR decorated OpVariable\n`gl_LaunchSizeEXT` -> LaunchSizeKHR decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexEXT` -> InstanceCustomIndexKHR decorated OpVariable\n`gl_GeometryIndexEXT` -> RayGeometryIndexKHR decorated OpVariable\n`gl_WorldRayOriginEXT` -> WorldRayOriginKHR decorated OpVariable\n`gl_WorldRayDirectionEXT` -> WorldRayDirectionKHR decorated OpVariable\n`gl_ObjectRayOriginEXT` -> ObjectRayOriginKHR decorated OpVariable\n`gl_ObjectRayDirectionEXT` -> ObjectRayDirectionKHR decorated OpVariable\n`gl_RayTminEXT` -> RayTminKHR decorated OpVariable\n`gl_RayTmaxEXT` -> RayTmaxKHR decorated OpVariable\n`gl_IncomingRayFlagsEXT` -> IncomingRayFlagsKHR decorated OpVariable\n`gl_HitTEXT` -> RayTmaxKHR decorated OpVariable\n`gl_HitKindEXT` -> HitKindKHR decorated OpVariable\n`gl_ObjectToWorldEXT` -> ObjectToWorldKHR decorated OpVariable\n`gl_WorldToObjectEXT` -> WorldToObjectKHR decorated OpVariable\n`gl_WorldToObject3x4EXT` -> Transpose of WorldToObjectKHR decorated OpVariable\n`gl_ObjectToWorld3x4EXT` -> Transpose of ObjectToWorldKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeEXT",
      "description": [
        "`gl_LaunchIDEXT` -> LaunchIdKHR decorated OpVariable\n`gl_LaunchSizeEXT` -> LaunchSizeKHR decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexEXT` -> InstanceCustomIndexKHR decorated OpVariable\n`gl_GeometryIndexEXT` -> RayGeometryIndexKHR decorated OpVariable\n`gl_WorldRayOriginEXT` -> WorldRayOriginKHR decorated OpVariable\n`gl_WorldRayDirectionEXT` -> WorldRayDirectionKHR decorated OpVariable\n`gl_ObjectRayOriginEXT` -> ObjectRayOriginKHR decorated OpVariable\n`gl_ObjectRayDirectionEXT` -> ObjectRayDirectionKHR decorated OpVariable\n`gl_RayTminEXT` -> RayTminKHR decorated OpVariable\n`gl_RayTmaxEXT` -> RayTmaxKHR decorated OpVariable\n`gl_IncomingRayFlagsEXT` -> IncomingRayFlagsKHR decorated OpVariable\n`gl_HitTEXT` -> RayTmaxKHR decorated OpVariable\n`gl_HitKindEXT` -> HitKindKHR decorated OpVariable\n`gl_ObjectToWorldEXT` -> ObjectToWorldKHR decorated OpVariable\n`gl_WorldToObjectEXT` -> WorldToObjectKHR decorated OpVariable\n`gl_WorldToObject3x4EXT` -> Transpose of WorldToObjectKHR decorated OpVariable\n`gl_ObjectToWorld3x4EXT` -> Transpose of ObjectToWorldKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeEXT",
      "description": [
        "`gl_LaunchIDEXT` -> LaunchIdKHR decorated OpVariable\n`gl_LaunchSizeEXT` -> LaunchSizeKHR decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexEXT` -> InstanceCustomIndexKHR decorated OpVariable\n`gl_GeometryIndexEXT` -> RayGeometryIndexKHR decorated OpVariable\n`gl_WorldRayOriginEXT` -> WorldRayOriginKHR decorated OpVariable\n`gl_WorldRayDirectionEXT` -> WorldRayDirectionKHR decorated OpVariable\n`gl_ObjectRayOriginEXT` -> ObjectRayOriginKHR decorated OpVariable\n`gl_ObjectRayDirectionEXT` -> ObjectRayDirectionKHR decorated OpVariable\n`gl_RayTminEXT` -> RayTminKHR decorated OpVariable\n`gl_RayTmaxEXT` -> RayTmaxKHR decorated OpVariable\n`gl_IncomingRayFlagsEXT` -> IncomingRayFlagsKHR decorated OpVariable\n`gl_HitTEXT` -> RayTmaxKHR decorated OpVariable\n`gl_HitKindEXT` -> HitKindKHR decorated OpVariable\n`gl_ObjectToWorldEXT` -> ObjectToWorldKHR decorated OpVariable\n`gl_WorldToObjectEXT` -> WorldToObjectKHR decorated OpVariable\n`gl_WorldToObject3x4EXT` -> Transpose of WorldToObjectKHR decorated OpVariable\n`gl_ObjectToWorld3x4EXT` -> Transpose of ObjectToWorldKHR decorated OpVariable"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeNV",
      "description": [
        "`gl_LaunchIDNV` -> LaunchIdNV decorated OpVariable\n`gl_LaunchSizeNV` -> LaunchSizeNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexNV` -> InstanceCustomIndexNV decorated OpVariable\n`gl_WorldRayOriginNV` -> WorldRayOriginNV decorated OpVariable\n`gl_WorldRayDirectionNV` -> WorldRayDirectionNV decorated OpVariable\n`gl_ObjectRayOriginNV` -> ObjectRayOriginNV decorated OpVariable\n`gl_ObjectRayDirectionNV` -> ObjectRayDirectionNV decorated OpVariable\n`gl_RayTminNV` -> RayTminNV decorated OpVariable\n`gl_RayTmaxNV` -> RayTmaxNV decorated OpVariable\n`gl_IncomingRayFlagsNV` -> IncomingRayFlagsNV decorated OpVariable\n`gl_HitTNV` -> HitTNV decorated OpVariable\n`gl_HitKindNV` -> HitKindNV decorated OpVariable\n`gl_ObjectToWorldNV` -> ObjectToWorldNV decorated OpVariable\n`gl_WorldToObjectNV` -> WorldToObjectNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeNV",
      "description": [
        "`gl_LaunchIDNV` -> LaunchIdNV decorated OpVariable\n`gl_LaunchSizeNV` -> LaunchSizeNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexNV` -> InstanceCustomIndexNV decorated OpVariable\n`gl_WorldRayOriginNV` -> WorldRayOriginNV decorated OpVariable\n`gl_WorldRayDirectionNV` -> WorldRayDirectionNV decorated OpVariable\n`gl_ObjectRayOriginNV` -> ObjectRayOriginNV decorated OpVariable\n`gl_ObjectRayDirectionNV` -> ObjectRayDirectionNV decorated OpVariable\n`gl_RayTminNV` -> RayTminNV decorated OpVariable\n`gl_RayTmaxNV` -> RayTmaxNV decorated OpVariable\n`gl_IncomingRayFlagsNV` -> IncomingRayFlagsNV decorated OpVariable\n`gl_HitTNV` -> HitTNV decorated OpVariable\n`gl_HitKindNV` -> HitKindNV decorated OpVariable\n`gl_ObjectToWorldNV` -> ObjectToWorldNV decorated OpVariable\n`gl_WorldToObjectNV` -> WorldToObjectNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeNV",
      "description": [
        "`gl_LaunchIDNV` -> LaunchIdNV decorated OpVariable\n`gl_LaunchSizeNV` -> LaunchSizeNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexNV` -> InstanceCustomIndexNV decorated OpVariable\n`gl_WorldRayOriginNV` -> WorldRayOriginNV decorated OpVariable\n`gl_WorldRayDirectionNV` -> WorldRayDirectionNV decorated OpVariable\n`gl_ObjectRayOriginNV` -> ObjectRayOriginNV decorated OpVariable\n`gl_ObjectRayDirectionNV` -> ObjectRayDirectionNV decorated OpVariable\n`gl_RayTminNV` -> RayTminNV decorated OpVariable\n`gl_RayTmaxNV` -> RayTmaxNV decorated OpVariable\n`gl_IncomingRayFlagsNV` -> IncomingRayFlagsNV decorated OpVariable\n`gl_HitTNV` -> HitTNV decorated OpVariable\n`gl_HitKindNV` -> HitKindNV decorated OpVariable\n`gl_ObjectToWorldNV` -> ObjectToWorldNV decorated OpVariable\n`gl_WorldToObjectNV` -> WorldToObjectNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeNV",
      "description": [
        "`gl_LaunchIDNV` -> LaunchIdNV decorated OpVariable\n`gl_LaunchSizeNV` -> LaunchSizeNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexNV` -> InstanceCustomIndexNV decorated OpVariable\n`gl_WorldRayOriginNV` -> WorldRayOriginNV decorated OpVariable\n`gl_WorldRayDirectionNV` -> WorldRayDirectionNV decorated OpVariable\n`gl_ObjectRayOriginNV` -> ObjectRayOriginNV decorated OpVariable\n`gl_ObjectRayDirectionNV` -> ObjectRayDirectionNV decorated OpVariable\n`gl_RayTminNV` -> RayTminNV decorated OpVariable\n`gl_RayTmaxNV` -> RayTmaxNV decorated OpVariable\n`gl_IncomingRayFlagsNV` -> IncomingRayFlagsNV decorated OpVariable\n`gl_HitTNV` -> HitTNV decorated OpVariable\n`gl_HitKindNV` -> HitKindNV decorated OpVariable\n`gl_ObjectToWorldNV` -> ObjectToWorldNV decorated OpVariable\n`gl_WorldToObjectNV` -> WorldToObjectNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LaunchSizeNV",
      "description": [
        "`gl_LaunchIDNV` -> LaunchIdNV decorated OpVariable\n`gl_LaunchSizeNV` -> LaunchSizeNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable\n`gl_InstanceID` -> InstanceId decorated OpVariable\n`gl_InstanceCustomIndexNV` -> InstanceCustomIndexNV decorated OpVariable\n`gl_WorldRayOriginNV` -> WorldRayOriginNV decorated OpVariable\n`gl_WorldRayDirectionNV` -> WorldRayDirectionNV decorated OpVariable\n`gl_ObjectRayOriginNV` -> ObjectRayOriginNV decorated OpVariable\n`gl_ObjectRayDirectionNV` -> ObjectRayDirectionNV decorated OpVariable\n`gl_RayTminNV` -> RayTminNV decorated OpVariable\n`gl_RayTmaxNV` -> RayTmaxNV decorated OpVariable\n`gl_IncomingRayFlagsNV` -> IncomingRayFlagsNV decorated OpVariable\n`gl_HitTNV` -> HitTNV decorated OpVariable\n`gl_HitKindNV` -> HitKindNV decorated OpVariable\n`gl_ObjectToWorldNV` -> ObjectToWorldNV decorated OpVariable\n`gl_WorldToObjectNV` -> WorldToObjectNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "out",
      "type": "int",
      "name": "gl_Layer",
      "description": [
        "In the geometry language, `gl_Layer` is used to select a specific layer (or face and layer of cube map) in a multi-layer framebuffer attachment. The actual layer used will come from one of the vertices in the primitive being shaded. Which vertex the layer comes from is undefined and as such it is recommended to write the same value to `gl_Layer` for all vertices in the primitive. If a shader statically assigns a value to `gl_Layer`, layered rendering mode is enabled. If a shader statically assigns a value to `gl_Layer`, and there is an execution path through the shader that does not set `gl_Layer`, then the value of `gl_Layer` is undefined for invocations of the shader that take that path.",
        "When used with an array of cube map textures, the `gl_Layer` output variable takes on a special value. Instead of referring to only the layer, it is used to select a cube map face and a layer. Setting `gl_Layer` to the value `layer * 6 + face` will render to `face` of the cube defined in `layer`. The face values are as follows:",
        "",
        "For example, to render to the positive y cube map face located in the 5th layer of the cube map array, `gl_Layer` should be set to `5 * 6 + 2`.",
        "The input variable `gl_Layer` in the fragment language will have the same value that was written to the output variable `gl_Layer` in the geometry language. If the geometry stage does not dynamically assign a value to `gl_Layer`, the value of `gl_Layer` in the fragment stage will be undefined. If the geometry stage makes no static assignment to `gl_Layer`, the input `gl_Layer` in the fragment stage will be zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_Layer`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_Layer",
      "description": [
        "In the geometry language, `gl_Layer` is used to select a specific layer (or face and layer of cube map) in a multi-layer framebuffer attachment. The actual layer used will come from one of the vertices in the primitive being shaded. Which vertex the layer comes from is undefined and as such it is recommended to write the same value to `gl_Layer` for all vertices in the primitive. If a shader statically assigns a value to `gl_Layer`, layered rendering mode is enabled. If a shader statically assigns a value to `gl_Layer`, and there is an execution path through the shader that does not set `gl_Layer`, then the value of `gl_Layer` is undefined for invocations of the shader that take that path.",
        "When used with an array of cube map textures, the `gl_Layer` output variable takes on a special value. Instead of referring to only the layer, it is used to select a cube map face and a layer. Setting `gl_Layer` to the value `layer * 6 + face` will render to `face` of the cube defined in `layer`. The face values are as follows:",
        "",
        "For example, to render to the positive y cube map face located in the 5th layer of the cube map array, `gl_Layer` should be set to `5 * 6 + 2`.",
        "The input variable `gl_Layer` in the fragment language will have the same value that was written to the output variable `gl_Layer` in the geometry language. If the geometry stage does not dynamically assign a value to `gl_Layer`, the value of `gl_Layer` in the fragment stage will be undefined. If the geometry stage makes no static assignment to `gl_Layer`, the input `gl_Layer` in the fragment stage will be zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_Layer`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LocalInvocationID",
      "description": [
        "In the compute language, `gl_LocalInvocationID` is an input variable containing the n-dimensional index of the local work invocation within the work group that the current shader is executing in. The possible values for this variable range across the local work group size, i.e., (0,0,0) to (`gl_WorkGroupSize.x` - 1, `gl_WorkGroupSize.y` - 1, `gl_WorkGroupSize.z` - 1)."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LocalInvocationID",
      "description": [
        "The built-in variable `gl_LocalInvocationID` is a compute, task, or mesh\nshader input variable containing the three-dimensional index of the local\nworkgroup within the global workgroup that the current invocation is\nexecuting in. ..."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_LocalInvocationID",
      "description": [
        "The built-in variable `gl_LocalInvocationID` is a compute, task, or mesh\nshader input variable containing the three-dimensional index of the local\nwork group within the global work group that the current invocation is\nexecuting in. ..."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_LocalInvocationIndex",
      "description": [
        "In the compute language, `gl_LocalInvocationIndex` is a derived input variable containing the 1-dimensional linearized index of the work invocation within the work group that the current shader is executing on. The value of `gl_LocalInvocationIndex` is equal to `gl_LocalInvocationID.z` * `gl_WorkGroupSize.x` * `gl_WorkGroupSize.y` + `gl_LocalInvocationID.y` * `gl_WorkGroupSize.x` + `gl_LocalInvocationID.x`."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_LocalInvocationIndex",
      "description": [
        "The built-in variable `gl_LocalInvocationIndex` is a compute, task, or mesh\nshader input variable that contains the one-dimensional representation of\nthe `gl_LocalInvocationID`."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_LocalInvocationIndex",
      "description": [
        "The built-in variable `gl_LocalInvocationIndex` is a compute, task, or mesh\nshader input variable that contains the one-dimensional representation of\nthe `gl_LocalInvocationID`."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "const",
      "type": "int",
      "name": "gl_MaxMeshViewCountNV",
      "default_value": "4",
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_MeshViewCountNV",
      "description": [
        "The input variable `gl_MeshViewCountNV` is only available in the mesh and\ntask languages and defines the number of views processed by the current\nmesh and task shader invocations.  When using the multi-view API feature,\nthe primitives emitted by the mesh shader will be processed separately for\neach enabled view and sent to a different layer of a layered render\ntarget.  Mesh shader outputs qualified with \"perviewNV\" are declared as\narrays with separate values for each view.  To ensure defined results,\nmesh shaders must write values for array elements zero through\n`gl_MeshViewCountNV`-1 for each such per-view output."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "bool",
      "name": "gl_NumSamples",
      "description": [
        "`gl_NumSamples` is a fragment language input variable that contains the number of samples in the framebuffer, or 1 if rendering to a non-multisample framebuffer. `gl_NumSamples` is the sample count of the framebuffer regardless of whether multisample rasterization is enabled or not."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_NumSubgroups",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_basic` is enabled, the variable\n`gl_NumSubgroups` is a compute-shader built-in containing the number of\nsubgroups within the local workgroup.  The value of this variable is at\nleast 1, and is uniform across the invocation group."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_NumWorkGroups",
      "description": [
        "In the compute language, `gl_NumWorkGroups` contains the total number of work groups that will execute the compute shader. The components of `gl_NumWorkGroups` are equal to the _num_groups_x_, _num_groups_y_, and _num_groups_z_ parameters passed to the `glDispatchCompute` command."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_NumWorkGroups",
      "description": [
        "The built-in variable `gl_NumWorkGroups` is a compute, task, or mesh shader\ninput variable containing the total number of global work items in each\ndimension of the workgroup that will execute the compute, task or mesh\nshader. ..."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayDirectionEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayDirectionEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayOriginEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayOriginEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_ObjectRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat3x4",
      "name": "gl_ObjectToWorld3x4EXT",
      "description": [
        "Add the following description for `gl_ObjectToWorld3x4EXT` and\n`gl_WorldToObject3x4EXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat3x4",
      "name": "gl_ObjectToWorld3x4EXT",
      "description": [
        "Add the following description for `gl_ObjectToWorld3x4EXT` and\n`gl_WorldToObject3x4EXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_ObjectToWorldEXT",
      "description": [
        "Add the following description for `gl_ObjectToWorldEXT` and\n`gl_WorldToObjectEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_ObjectToWorldEXT",
      "description": [
        "Add the following description for `gl_ObjectToWorldEXT` and\n`gl_WorldToObjectEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_ObjectToWorldNV",
      "description": [
        "Add the following description for `gl_ObjectToWorldNV` and\n`gl_WorldToObjectNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_ObjectToWorldNV",
      "description": [
        "Add the following description for `gl_ObjectToWorldNV` and\n`gl_WorldToObjectNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PatchVerticesIn",
      "description": [
        "Available only in the tessellation control and evaluation languages, `gl_PatchVerticesIn` contains the number of vertices in the input being processed by the shader. A single tessellation control or evaluation shader can read patches of differing sizes, and so th value of `gl_PatchVertexIn` may differ between patches."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "vec2",
      "name": "gl_PointCoord",
      "description": [
        "`gl_PointCoord` is a fragment language input variable that contains the two-dimensional coordinates indicating where within a point primitive the current fragment is located. If the current primitive is not a point, then values read from `gl_PointCoord` are undefined.",
        "`gl_PointCoord.s` ranges from 0.0 to 1.0 across the point horizontally from left to right. If `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_LOWER_LEFT`, `gl_PointCoord.t` varies from 0.0 to 1.0 vertically from bottom to top. Otherwise, if `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_UPPER_LEFT` then `gl_PointCoord.t` varies from 0.0 to 1.0 vertically from top to bottom. The default value of `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_UPPER_LEFT`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "name": "gl_Position",
      "type": "vec4",
      "description": [
        "In the vertex, tessellation evaluation and geometry languages, a single global instance of the `gl_PerVertex` named block is available and its `gl_Position` member is an output that receives the homogeneous vertex position. It may be written at any time during shader execution. The value written to `gl_Position` will be used by primitive assembly, clipping, culling and other fixed functionality operations, if present, that operate on primitives after vertex processing has occurred.",
        "In the tessellation control language, the `gl_PerVertex` named block is used to construct an array, `gl_out[]`, whose `gl_Position` members hold the homogeneous control point position, which become available as inputs to the subsequent tessellation evaluation shader.",
        "The value of `gl_Position` (or the `gl_Position` member of the `gl_out[]` array, in the case of the tessellation control shader) is undefined after the vertex, tessellation control, and tessellation evaluation shading stages if the corresponding shader executable does not write to gl_Position. It is also undefined after the geometry processing stage if the geometry shader executable calls EmitVertex without having written `gl_Position` since the last call to EmitVertex (or hasn't written it at all).",
        "In the tessellation control, tessellation evaluation and geometry languages, the `gl_PerVertex` named block is used to construct an array, `gl_in[]` of per-vertex or per-control point inputs whose content represents the corresponding outputs written by the previous stage."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "`gl_PrimitiveID` is a tessellation control, tessellation evaluation and fragment language input variable. For the tessellation control and tessellation evaluation languages, it holds the number of primitives processed by the shader since the current set of rendering primitives was started. The first primitive processed by the drawing command is numbered zero and the primitive ID counter is incremented after every individual point, line or triangle primitive is processed. For triangles drawn in point or line mode, the primitive ID counter is incremented only once, even through multiple points or lines may actually be drawn. Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter.",
        "In the geometry language, `gl_PrimitiveID` is an output variable that is passed to the corresponding `gl_PrimitiveID` input variable in the fragment shader. If no geomery shader is present then `gl_PrimitiveID` in the fragment language behaves identically as it would in the tessellation control and evaluation languages. If a geometry shader is present but does not write to `gl_PrimitiveID`, the value of `gl_PrimitiveID` in the fragment shader is undefined."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "out",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "`gl_PrimitiveID` is a tessellation control, tessellation evaluation and fragment language input variable. For the tessellation control and tessellation evaluation languages, it holds the number of primitives processed by the shader since the current set of rendering primitives was started. The first primitive processed by the drawing command is numbered zero and the primitive ID counter is incremented after every individual point, line or triangle primitive is processed. For triangles drawn in point or line mode, the primitive ID counter is incremented only once, even through multiple points or lines may actually be drawn. Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter.",
        "In the geometry language, `gl_PrimitiveID` is an output variable that is passed to the corresponding `gl_PrimitiveID` input variable in the fragment shader. If no geomery shader is present then `gl_PrimitiveID` in the fragment language behaves identically as it would in the tessellation control and evaluation languages. If a geometry shader is present but does not write to `gl_PrimitiveID`, the value of `gl_PrimitiveID` in the fragment shader is undefined."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "Add the following description for `gl_PrimitiveID`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "Add the following description for `gl_PrimitiveID`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "Add the following description for `gl_PrimitiveID`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveID",
      "description": [
        "Add the following description for `gl_PrimitiveID`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_PrimitiveIDIn",
      "description": [
        "`gl_PrimitiveIDIn` is a geometry language input variable that holds the number of primitives processed by the shader since the current set of rendering primitives was started. The first primitive processed by the drawing command is numbered zero and the primitive ID counter is incremented after every individual point, line or triangle primitive is processed. For triangles drawn in point or line mode, the primitive ID counter is incremented only once, even through multiple points or lines may actually be drawn. Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullBackFacingTrianglesEXT",
      "default_value": "16U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullBackFacingTrianglesEXT",
      "default_value": "16U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullBackFacingTrianglesNV",
      "default_value": "16U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullFrontFacingTrianglesEXT",
      "default_value": "32U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullFrontFacingTrianglesEXT",
      "default_value": "32U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullFrontFacingTrianglesNV",
      "default_value": "32U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullNoOpaqueEXT",
      "default_value": "128U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullNoOpaqueEXT",
      "default_value": "128U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullNoOpaqueNV",
      "default_value": "128U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullOpaqueEXT",
      "default_value": "64U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullOpaqueEXT",
      "default_value": "64U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsCullOpaqueNV",
      "default_value": "64U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsForceOpacityMicromap2StateEXT",
      "default_value": "1024U",
      "extensions": [
        "GL_EXT_opacity_micromap"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoOpaqueEXT",
      "default_value": "2U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoOpaqueEXT",
      "default_value": "2U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoOpaqueNV",
      "default_value": "2U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoneEXT",
      "default_value": "0U",
      "description": [
        "const uint `gl_RayFlagsNoneEXT` = 0U;\nconst uint `gl_RayFlagsOpaqueEXT` = 1U;\nconst uint `gl_RayFlagsNoOpaqueEXT` = 2U;\nconst uint `gl_RayFlagsTerminateOnFirstHitEXT` = 4U;\nconst uint `gl_RayFlagsSkipClosestHitShaderEXT` = 8U;\nconst uint `gl_RayFlagsCullBackFacingTrianglesEXT` = 16U;\nconst uint `gl_RayFlagsCullFrontFacingTrianglesEXT` = 32U;\nconst uint `gl_RayFlagsCullOpaqueEXT` = 64U;\nconst uint `gl_RayFlagsCullNoOpaqueEXT` = 128U;"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoneEXT",
      "default_value": "0U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsNoneNV",
      "default_value": "0U",
      "description": [
        "const uint `gl_RayFlagsNoneNV` = 0U;\nconst uint `gl_RayFlagsOpaqueNV` = 1U;\nconst uint `gl_RayFlagsNoOpaqueNV` = 2U;\nconst uint `gl_RayFlagsTerminateOnFirstHitNV` = 4U;\nconst uint `gl_RayFlagsSkipClosestHitShaderNV` = 8U;\nconst uint `gl_RayFlagsCullBackFacingTrianglesNV` = 16U;\nconst uint `gl_RayFlagsCullFrontFacingTrianglesNV` = 32U;\nconst uint `gl_RayFlagsCullOpaqueNV` = 64U;\nconst uint `gl_RayFlagsCullNoOpaqueNV` = 128U;"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsOpaqueEXT",
      "default_value": "1U",
      "description": [
        "`gl_RayFlagsNoneEXT` -> NoneKHR ray flag\n`gl_RayFlagsOpaqueEXT` -> OpaqueKHR ray flag\n`gl_RayFlagsNoOpaqueEXT` -> NoOpaqueKHR ray flag\n`gl_RayFlagsTerminateOnFirstHitEXT` -> TerminateOnFirstHitKHR ray flag\n`gl_RayFlagsSkipClosestHitShaderEXT` -> SkipClosestHitShaderKHR ray flag\n`gl_RayFlagsCullBackFacingTrianglesEXT` -> CullBackFacingTrianglesKHR ray flag\n`gl_RayFlagsCullFrontFacingTrianglesEXT` -> CullFrontFacingTrianglesKHR ray flag\n`gl_RayFlagsCullOpaqueEXT` -> CullOpaqueKHR ray flag\n`gl_RayFlagsCullNoOpaqueEXT` -> CullNoOpaqueKHR ray flag"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsOpaqueEXT",
      "default_value": "1U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsOpaqueNV",
      "default_value": "1U",
      "description": [
        "`gl_RayFlagsNoneNV` -> constant, no semantic needed\n`gl_RayFlagsOpaqueNV` -> constant, no semantic needed\n`gl_RayFlagsNoOpaqueNV` -> constant, no semantic needed\n`gl_RayFlagsTerminateOnFirstHitNV` -> constant, no semantic needed\n`gl_RayFlagsSkipClosestHitShaderNV` -> constant, no semantic needed\n`gl_RayFlagsCullBackFacingTrianglesNV` -> constant, no semantic needed\n`gl_RayFlagsCullFrontFacingTrianglesNV` -> constant, no semantic needed\n`gl_RayFlagsCullOpaqueNV` -> constant, no semantic needed\n`gl_RayFlagsCullNoOpaqueNV` -> constant, no semantic needed"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsSkipAABBEXT",
      "default_value": "512U",
      "extensions": [
        "GL_EXT_ray_flags_primitive_culling"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsSkipClosestHitShaderEXT",
      "default_value": "8U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsSkipClosestHitShaderEXT",
      "default_value": "8U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsSkipClosestHitShaderNV",
      "default_value": "8U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsSkipTrianglesEXT",
      "default_value": "256U",
      "extensions": [
        "GL_EXT_ray_flags_primitive_culling"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsTerminateOnFirstHitEXT",
      "default_value": "4U",
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsTerminateOnFirstHitEXT",
      "default_value": "4U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayFlagsTerminateOnFirstHitNV",
      "default_value": "4U",
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayQueryCandidateIntersectionAABBEXT",
      "default_value": "1U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayQueryCandidateIntersectionTriangleEXT",
      "default_value": "0U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayQueryCommittedIntersectionGeneratedEXT",
      "default_value": "2U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayQueryCommittedIntersectionNoneEXT",
      "default_value": "0U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "const",
      "type": "uint",
      "name": "gl_RayQueryCommittedIntersectionTriangleEXT",
      "default_value": "1U",
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTmaxEXT",
      "description": [
        "Add the following description for `gl_RayTminEXT` and `gl_RayTmaxEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTmaxEXT",
      "description": [
        "Add the following description for `gl_RayTminEXT` and `gl_RayTmaxEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTmaxNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTmaxNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTmaxNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminEXT",
      "description": [
        "Add the following description for `gl_RayTminEXT` and `gl_RayTmaxEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminEXT",
      "description": [
        "Add the following description for `gl_RayTminEXT` and `gl_RayTmaxEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminEXT",
      "description": [
        "Add the following description for `gl_RayTminEXT` and `gl_RayTmaxEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "float",
      "name": "gl_RayTminNV",
      "description": [
        "Add the following description for `gl_RayTminNV` and `gl_RayTmaxNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_SMCountNV",
      "description": [
        "`gl_WarpsPerSMNV` -> WarpsPerSMNV decorated OpVariable\n`gl_SMCountNV` -> SMCountNV decorated OpVariable\n`gl_WarpIDNV` -> WarpIDNV decorated OpVariable\n`gl_SMIDNV` -> SMIDNV decorated OpVariable"
      ],
      "extensions": [
        "GL_NV_shader_sm_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_SMIDNV",
      "description": [
        "The variable `gl_SMIDNV` holds the SM id of the executing invocation.\nThis variable is in the range 0 to `gl_SMCountNV`-1."
      ],
      "extensions": [
        "GL_NV_shader_sm_builtins"
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_SampleID",
      "description": [
        "`gl_SampleID` is a fragment language input variable that contains the index of the sample currently being processed. This variable is in the range 0 to gl_NumSamples - 1, where gl_NumSamples is the total number of samples in each fragment for the current framebuffer (and thus 1 if rendering to a non-multisample buffer). Any static use of this variable in a fragment shader causes the entire shader to be evaluated per-sample rather than per-fragment.",
        "When rendering to a non-multisample buffer, or if multisample rasterization is disabled, `gl_SampleID` will always be zero. gl_NumSamples is the sample count of the framebuffer regardless of whether multisample rasterization is enabled or not."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "out",
      "type": "int[]",
      "name": "gl_SampleMask",
      "description": [
        "`gl_SampleMask` is a fragment language output array that may be used to set the sample mask for the fragment being processed. Coverage for the current fragment will become the logical AND of the coverage mask and the output `gl_SampleMask`. That is, setting a bit in `gl_SampleMask` to zero will cause the corresponding sample to be considered uncovered for the purposes of multisample fragment operations. However, setting sample mask bits back to one will never enable samples not covered by the original primitive. Bit _B_ of mask `gl_SampleMask[M]` corresponds to sample 32 * _M_ + _B_. This array must be sized in the fragment shader either implicitly or explicitly to be the same size as the implementation-dependent maximum sample-mask (as an array of 32-bit elements), determined by the maximum number of samples. If the fragment shader statically assigns a value to `gl_SampleMask`, the sample mask will be undefined for any array elements of any fragment shader invocation that fails to assign a value. If a shader does not statically assign a value to `gl_SampleMask`, the sample mask has no effect on the processing of a fragment. If the fragment shader is being evaluated at any frequency other than per-fragment, bits within the sample mask not corresponding to the current fragment shader invocation are ignored."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int[]",
      "name": "gl_SampleMaskIn",
      "description": [
        "`gl_SampleMaskIn` is a fragment language that indicates the set of samples covered by the primitive generating the fragment during multisample rasterization. It has a sample bit set if and only if the sample is considered covered for this fragment shader invocation. Bit _B_ of mask `gl_SampleMask[M]` corresponds to sample 32 * _M_ + _B_. The array has `ceil`(_s_ / 32) elements where _s_ is the maximum number of color samples supported by the implementation."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "vec2",
      "name": "gl_SamplePosition",
      "description": [
        "`gl_SamplePosition` is a fragment language input variable that contains the location within a fragment of the sample currently being processed. The x and y components of `gl_SamplePosition` contain the sub-pixel coordinate of the current sample and will have values in the range 0.0 to 1.0. The sub-pixel coordinates of the center of the pixel are always (0.5, 0.5). Any static use of `gl_SamplePosition` causes the entire fragment shader to be evaluated per-sample rather than per-fragment. When rendering to a non-multisample buffer, or if multisample rasterization is disabled, `gl_SamplePosition` will be (0.5, 0.5)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "const",
      "type": "int",
      "name": "gl_ShadingRateFlag2HorizontalPixelsEXT",
      "default_value": "4",
      "extensions": [
        "GL_EXT_fragment_shading_rate"
      ]
    },
    {
      "modifiers": "const",
      "type": "int",
      "name": "gl_ShadingRateFlag2VerticalPixelsEXT",
      "default_value": "1",
      "extensions": [
        "GL_EXT_fragment_shading_rate"
      ]
    },
    {
      "modifiers": "const",
      "type": "int",
      "name": "gl_ShadingRateFlag4HorizontalPixelsEXT",
      "default_value": "8",
      "extensions": [
        "GL_EXT_fragment_shading_rate"
      ]
    },
    {
      "modifiers": "const",
      "type": "int",
      "name": "gl_ShadingRateFlag4VerticalPixelsEXT",
      "default_value": "2",
      "extensions": [
        "GL_EXT_fragment_shading_rate"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uvec4",
      "name": "gl_SubgroupEqMask",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_ballot` is enabled, the\n`gl_Subgroup`??Mask> variables are built-ins that provide a bitmask of all\ninvocations, with one bit per invocation.  Bit 0 of the first vector\ncomponent represents the first invocation, higher-order bits within a\ncomponent and higher component numbers both represent, in order, higher\ninvocations, and the last invocation is the highest-order bit needed, in the\nlast component needed, to contiguously represent all bits of the invocations\nin a subgroup.  These variables are defined according to the following\ntable:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uvec4",
      "name": "gl_SubgroupGeMask",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_ballot` is enabled, the\n`gl_Subgroup`??Mask> variables are built-ins that provide a bitmask of all\ninvocations, with one bit per invocation.  Bit 0 of the first vector\ncomponent represents the first invocation, higher-order bits within a\ncomponent and higher component numbers both represent, in order, higher\ninvocations, and the last invocation is the highest-order bit needed, in the\nlast component needed, to contiguously represent all bits of the invocations\nin a subgroup.  These variables are defined according to the following\ntable:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uvec4",
      "name": "gl_SubgroupGtMask",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_ballot` is enabled, the\n`gl_Subgroup`??Mask> variables are built-ins that provide a bitmask of all\ninvocations, with one bit per invocation.  Bit 0 of the first vector\ncomponent represents the first invocation, higher-order bits within a\ncomponent and higher component numbers both represent, in order, higher\ninvocations, and the last invocation is the highest-order bit needed, in the\nlast component needed, to contiguously represent all bits of the invocations\nin a subgroup.  These variables are defined according to the following\ntable:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_SubgroupID",
      "description": [
        "`gl_NumSubgroups` -> NumSubgroups decorated OpVariable\n`gl_SubgroupID` -> SubgroupId decorated OpVariable\n`gl_SubgroupSize` -> SubgroupSize decorated OpVariable\n`gl_SubgroupInvocationID` -> SubgroupLocalInvocationId decorated OpVariable\n`gl_SubgroupEqMask` -> SubgroupEqMask decorated OpVariable\n`gl_SubgroupGeMask` -> SubgroupGeMask decorated OpVariable\n`gl_SubgroupGtMask` -> SubgroupGtMask decorated OpVariable\n`gl_SubgroupLeMask` -> SubgroupLeMask decorated OpVariable\n`gl_SubgroupLtMask` -> SubgroupLtMask decorated OpVariable"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_SubgroupInvocationID",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_basic` is enabled, the variable\n`gl_SubgroupInvocationID` is a built-in containing the index of an\ninvocation within a subgroup.  The value of this variable is in the range\n0 to `gl_SubgroupSize`-1."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uvec4",
      "name": "gl_SubgroupLeMask",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_ballot` is enabled, the\n`gl_Subgroup`??Mask> variables are built-ins that provide a bitmask of all\ninvocations, with one bit per invocation.  Bit 0 of the first vector\ncomponent represents the first invocation, higher-order bits within a\ncomponent and higher component numbers both represent, in order, higher\ninvocations, and the last invocation is the highest-order bit needed, in the\nlast component needed, to contiguously represent all bits of the invocations\nin a subgroup.  These variables are defined according to the following\ntable:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uvec4",
      "name": "gl_SubgroupLtMask",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_ballot` is enabled, the\n`gl_Subgroup`??Mask> variables are built-ins that provide a bitmask of all\ninvocations, with one bit per invocation.  Bit 0 of the first vector\ncomponent represents the first invocation, higher-order bits within a\ncomponent and higher component numbers both represent, in order, higher\ninvocations, and the last invocation is the highest-order bit needed, in the\nlast component needed, to contiguously represent all bits of the invocations\nin a subgroup.  These variables are defined according to the following\ntable:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "in",
      "type": "uint",
      "name": "gl_SubgroupSize",
      "description": [
        "If the extension `GL_KHR_shader_subgroup_basic` is enabled, the variable\n`gl_SubgroupSize` is the number of invocations within a subgroup, and its\nvalue is always a power of 2.  The maximum `gl_SubgroupSize` supported by\nthe `GL_KHR_shader_subgroup_basic` extension is 128."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "modifiers": "out",
      "type": "uint",
      "name": "gl_TaskCountNV",
      "description": [
        "When a task shader work group is executed, its invocations execute in\nparallel and evaluate geometry associated with the task.  The task shader\nhas no built-in or user-defined input variables other than the built-ins\nidentifying the work group and invocation being executed.  The task shader\ncan use that information to read properties of the geometry associated\nwith the task from memory, using shader storage buffers, textures, or\nother resources.  The task shader determines the number of mesh shader\ntasks that should be spawned for the task it is processing and writes the\ntask count to the built-in variable `gl_TaskCountNV`.  Additionally, the\ntask shader can compute and write additional properties of the geometry it\nprocesses to user-defined output variables qualified with \"taskNV\" to\ntask memory, which can be read as inputs by all of the mesh shaders that\nit spawns.  The task shader can be used to drive level-of-detail\ncalculations for procedurally generated geometry, to perform coarse-level\nculling for batches of static or dynamic geometry, and for other forms of\nwork reduction or amplification."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_TessCoord",
      "description": [
        "Available only in the tessellation cevaluation language, `gl_TessCoord` specifies the three component (u, v, w) vector identifying the position of the vertex being processed by the shader relative to the primitive being tessellated."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "out",
      "type": "float[2]",
      "name": "gl_TessLevelInner",
      "description": [
        "Available only in the tessellation control and evaluation languages, `gl_TessLevelInner` is used to assign values to the corresponding inner tesellation levels of the current patch. The values written into `gl_TessLevelInner` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.",
        "As inputs to the tessellation evaluation shader, `gl_TessLevelInner` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "float[2]",
      "name": "gl_TessLevelInner",
      "description": [
        "Available only in the tessellation control and evaluation languages, `gl_TessLevelInner` is used to assign values to the corresponding inner tesellation levels of the current patch. The values written into `gl_TessLevelInner` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.",
        "As inputs to the tessellation evaluation shader, `gl_TessLevelInner` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "out",
      "type": "float[4]",
      "name": "gl_TessLevelOuter",
      "description": [
        "Available only in the tessellation control and evaluation languages, `gl_TessLevelOuter` is used to assign values to the corresponding outer tesellation levels of the current patch. The values written into `gl_TessLevelOuter` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.",
        "As inputs to the tessellation evaluation shader, `gl_TessLevelOuter` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "float[4]",
      "name": "gl_TessLevelOuter",
      "description": [
        "Available only in the tessellation control and evaluation languages, `gl_TessLevelOuter` is used to assign values to the corresponding outer tesellation levels of the current patch. The values written into `gl_TessLevelOuter` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.",
        "As inputs to the tessellation evaluation shader, `gl_TessLevelOuter` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_VertexID",
      "description": [
        "`gl_VertexID` is a vertex language input variable that holds an integer index for the vertex. The index is impliclty generated by `glDrawArrays` and other commands that do not reference the content of the `GL_ELEMENT_ARRAY_BUFFER`, or explicitly generated from the content of the `GL_ELEMENT_ARRAY_BUFFER` by commands such as `glDrawElements`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "description": [
        "The variable `gl_VertexIndex` is a vertex language input variable that holds an integer index for the vertex, relative to a base. While the variable `gl_VertexIndex` is always present, its value is not always defined."
      ],
      "modifiers": "in",
      "name": "gl_VertexIndex",
      "type": "int",
      "versions": [
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_VertexIndex",
      "description": [
        "The variable `gl_VertexIndex` is a vertex language input variable that holds an integer index for the vertex, relative to a base. While the variable `gl_VertexIndex` is always present, its value is not always defined."
      ],
      "versions": [
        450
      ]
    },
    {
      "modifiers": "highp",
      "type": "int",
      "name": "gl_ViewIndex",
      "description": [
        "Add the following description for `gl_ViewIndex`:"
      ],
      "extensions": [
        "GL_EXT_multiview"
      ]
    },
    {
      "modifiers": "out",
      "type": "int",
      "name": "gl_ViewportIndex",
      "description": [
        "In the geometry language, `gl_ViewportIndex` is used to specify the index of the viewport to which the next primitive emitted from the shader should be drawn. Primitives generated by the geometry shader will undergo viewport transformation and scissor testing using the viewport transformation and scissor rectangle selected by the value of `gl_ViewportIndex`. The viewport index used will come from one of the vertices in the primitive being shaded. However, which vertex the viewport index comes from is implementation-defined, and so it is recommended to use the same viewport index for all vertices of a primitive. If a geometry shader does not assign a value to `gl_ViewportIndex`, viewport transform and scissor rectangle zero will be used. If a geometry shader statically assigns a value to `gl_ViewportIndex` and there is a path through the shader that does not assign a value to `gl_ViewportIndex`, the value of `gl_ViewportIndex` is undefined for executions of the shader that take that path.",
        "In the fragment language, `gl_ViewportIndex` will have the same value that was written to the output variable `gl_ViewportIndex` in the geometry stage. If the geometry stage does not dynamically assign to `gl_ViewportIndex`, the value of `gl_ViewportIndex` in the fragment shader will be undefined. If the geometry stage makes no static assignment to `gl_ViewportIndex`, the fragment stage will read zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_ViewportIndex`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "int",
      "name": "gl_ViewportIndex",
      "description": [
        "In the geometry language, `gl_ViewportIndex` is used to specify the index of the viewport to which the next primitive emitted from the shader should be drawn. Primitives generated by the geometry shader will undergo viewport transformation and scissor testing using the viewport transformation and scissor rectangle selected by the value of `gl_ViewportIndex`. The viewport index used will come from one of the vertices in the primitive being shaded. However, which vertex the viewport index comes from is implementation-defined, and so it is recommended to use the same viewport index for all vertices of a primitive. If a geometry shader does not assign a value to `gl_ViewportIndex`, viewport transform and scissor rectangle zero will be used. If a geometry shader statically assigns a value to `gl_ViewportIndex` and there is a path through the shader that does not assign a value to `gl_ViewportIndex`, the value of `gl_ViewportIndex` is undefined for executions of the shader that take that path.",
        "In the fragment language, `gl_ViewportIndex` will have the same value that was written to the output variable `gl_ViewportIndex` in the geometry stage. If the geometry stage does not dynamically assign to `gl_ViewportIndex`, the value of `gl_ViewportIndex` in the fragment shader will be undefined. If the geometry stage makes no static assignment to `gl_ViewportIndex`, the fragment stage will read zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_ViewportIndex`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_WarpIDARM",
      "description": [
        "The variable `gl_WarpIDARM` holds the warp ID of the executing invocation.\nThis variable is in the range 0 to `gl_MaxWarpIDARM`."
      ],
      "extensions": [
        "GL_ARM_shader_core_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_WarpIDNV",
      "description": [
        "The variable `gl_WarpIDNV` holds the warp id of the executing invocation.\nThis variable is in the range 0 to `gl_WarpsPerSMNV`-1."
      ],
      "extensions": [
        "GL_NV_shader_sm_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_WarpMaxIDARM",
      "description": [
        "The variable `gl_WarpMaxIDARM` holds the max ID that can be assigned to a\nwarp on the core the executing invocation is running on."
      ],
      "extensions": [
        "GL_ARM_shader_core_builtins"
      ]
    },
    {
      "modifiers": "highp in",
      "type": "uint",
      "name": "gl_WarpsPerSMNV",
      "description": [
        "The variable `gl_WarpsPerSMNV` holds the maximum number of warps executing\non a SM."
      ],
      "extensions": [
        "GL_NV_shader_sm_builtins"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_WorkGroupID",
      "description": [
        "In the compute language, `gl_WorkGroupID` contains the 3-dimensional index of the global work group that the current compute shader invocation is executing within. The possible values range across the parameters passed into `glDispatchCompute`, i.e., from (0, 0, 0) to (`gl_NumWorkGroups.x` - 1, `gl_NumWorkGroups.y` - 1, `gl_NumWorkGroups.z` - 1)."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_WorkGroupID",
      "description": [
        "The built-in variable `gl_WorkGroupID` is a compute, task, or mesh shader\ninput variable containing the three-dimensional index of the global work\ngroup that the current invocation is executing in. ..."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "uvec3",
      "name": "gl_WorkGroupID",
      "description": [
        "`gl_WorkGroupSize` -> WorkgroupSize decorated OpVariable (existing)\n`gl_WorkGroupID` -> WorkgroupId decorated OpVariable (existing)\n`gl_LocalInvocationID` -> LocalInvocationId decorated OpVariable (existing)\n`gl_GlobalInvocationID` -> GlobalInvocationId decorated OpVariable (existing)\n`gl_LocalInvocationIndex` -> LocalInvocationIndex decorated OpVariable (existing)\n`gl_TaskCountNV` -> TaskCountNV decorated OpVariable\n`gl_PrimitiveCountNV` -> PrimitiveCountNV decorated OpVariable\n`gl_PrimitiveIndicesNV` -> PrimitiveIndicesNV decorated OpVariable\n`gl_Position` -> Position decorated OpVariable (existing)\n`gl_PositionPerViewNV` -> PositionPerViewNV decorated OpVariable (existing extension)\n`gl_PointSize` -> PointSize decorated OpVariable (existing)\n`gl_ClipDistance` -> ClipDistance decorated OpVariable (existing)\n`gl_ClipDistancePerViewNV` -> ClipDistancePerViewNV decorated OpVariable\n`gl_CullDistance` -> CullDistance decorated OpVariable (existing)\n`gl_CullDistancePerViewNV` -> CullDistancePerViewNV decorated OpVariable\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable (existing)\n`gl_Layer` -> Layer decorated OpVariable (existing)\n`gl_LayerPerViewNV` -> LayerPerViewNV decorated OpVariable\n`gl_ViewportIndex` -> ViewportIndex decorated OpVariable (existing)\n`gl_ViewportMask` -> ViewportMaskNV decorated OpVariable (existing extension)\n`gl_ViewportMaskPerViewNV` -> ViewportMaskPerViewNV decorated OpVariable (existing extension)\n`gl_MeshViewCountNV` -> MeshViewCountNV decorated OpVariable\n`gl_MeshViewIndicesNV` -> MeshViewIndicesNV decorated OpVariable\n`gl_DrawID` -> DrawIndex decorated OpVariable (existing 1.3, extension)"
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "const",
      "type": "uvec3",
      "name": "gl_WorkGroupSize",
      "description": [
        "In the compute language, `gl_WorkGroupSize` contains the size of a workgroup declared by a compute shader. The size of the work group in the X, Y, and Z dimensions is stored in the x, y, and z components of `gl_WorkGroupSize`. The values stored in `gl_WorkGroupSize` match those specified in the required `local_size_x`, `local_size_y`, and `local_size_z` layout qualifiers for the current shader. This value is constant so that it can be used to size arrays of memory that can be shared within the local work group."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "modifiers": "const",
      "type": "uvec3",
      "name": "gl_WorkGroupSize",
      "description": [
        "`gl_NumWorkGroups` -> NumWorkgroups decorated OpVariable (existing)\n`gl_WorkGroupSize` -> WorkgroupSize decorated OpVariable (existing)\n`gl_WorkGroupID` -> WorkgroupId decorated OpVariable (existing)\n`gl_LocalInvocationID` -> LocalInvocationId decorated OpVariable (existing)\n`gl_GlobalInvocationID` -> GlobalInvocationId decorated OpVariable (existing)\n`gl_LocalInvocationIndex` -> LocalInvocationIndex decorated OpVariable (existing)\n`gl_PrimitivePointIndicesEXT` -> PrimitivePointIndicesEXT decorated OpVariable\n`gl_PrimitiveLineIndicesEXT` -> PrimitiveLineIndicesEXT decorated OpVariable\n`gl_PrimitiveTriangleIndicesEXT` -> PrimitiveTriangleIndicesEXT decorated OpVariable\n`gl_Position` -> Position decorated OpVariable (existing)\n`gl_PointSize` -> PointSize decorated OpVariable (existing)\n`gl_ClipDistance` -> ClipDistance decorated OpVariable (existing)\n`gl_CullDistance` -> CullDistance decorated OpVariable (existing)\n`gl_PrimitiveID` -> PrimitiveId decorated OpVariable (existing)\n`gl_Layer` -> Layer decorated OpVariable (existing)\n`gl_ViewportIndex` -> ViewportIndex decorated OpVariable (existing)\n`gl_CullPrimitiveEXT` -> CullPrimitiveEXT decorated OpVariable\n`gl_DrawID` -> DrawIndex decorated OpVariable (existing 1.3, extension)"
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "modifiers": "const",
      "type": "uvec3",
      "name": "gl_WorkGroupSize",
      "description": [
        "The built-in constant `gl_WorkGroupSize` is a compute, task, or mesh shader\nconstant containing the local work-group size of the shader. The size ..."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayDirectionNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginEXT",
      "description": [
        "Add the following description for `gl_WorldRayOriginEXT`, `gl_WorldRayDirectionEXT`,\n`gl_ObjectRayOriginEXT`, and `gl_ObjectRayDirectionEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "vec3",
      "name": "gl_WorldRayOriginNV",
      "description": [
        "Add the following description for `gl_WorldRayOriginNV`, `gl_WorldRayDirectionNV`,\n`gl_ObjectRayOriginNV`, and `gl_ObjectRayDirectionNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat3x4",
      "name": "gl_WorldToObject3x4EXT",
      "description": [
        "Add the following description for `gl_ObjectToWorld3x4EXT` and\n`gl_WorldToObject3x4EXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat3x4",
      "name": "gl_WorldToObject3x4EXT",
      "description": [
        "Add the following description for `gl_ObjectToWorld3x4EXT` and\n`gl_WorldToObject3x4EXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_WorldToObjectEXT",
      "description": [
        "Add the following description for `gl_ObjectToWorldEXT` and\n`gl_WorldToObjectEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_WorldToObjectEXT",
      "description": [
        "Add the following description for `gl_ObjectToWorldEXT` and\n`gl_WorldToObjectEXT`:"
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_WorldToObjectNV",
      "description": [
        "Add the following description for `gl_ObjectToWorldNV` and\n`gl_WorldToObjectNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "modifiers": "in",
      "type": "mat4x3",
      "name": "gl_WorldToObjectNV",
      "description": [
        "Add the following description for `gl_ObjectToWorldNV` and\n`gl_WorldToObjectNV`:"
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "description": [
        "2"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gnormal",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "gtexture",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Whether the current dimension has a ceiling (like the Nether).",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "hasCeiling",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Whether the current dimension has skylight.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "hasSkylight",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The maximum height of the current dimension.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "heightLimit",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "held item light value (main hand)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "heldBlockLightValue",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "held item light value (off hand)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "heldBlockLightValue2",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "held item ID (main hand), used only for items defined in \"item.properties\""
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "heldItemId",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "held item ID (off hand), used only for items defined in \"item.properties\""
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "heldItemId2",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "GUI is hidden"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "hideGUI",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "instance ID when instancing is enabled (countInstances > 1), 0 = original, 1-N = copies"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "instanceId",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "1 = camera is in water, 2 = camera is in lava, 3 = camera is in powder snow"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "isEyeInWater",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when in spectator mode.",
        "Added in Iris 1.4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "isSpectator",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when the player is on fire.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_burning",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True for a short time after the player is hurt for any reason, then returns to false.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_hurt",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True both when using an invisibility potion and when in spectator mode.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_invisible",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when the player is not flying and is on the ground, false otherwise.",
        "Added in Iris 1.6.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_on_ground",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when the player is sneaking.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_sneaking",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "True when the player is sprinting.",
        "Added in Iris 1.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "is_sprinting",
      "type": "bool",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "1"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "lightmap",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Position of a lightning bolt currently being rendered. If there are none, zero is returned. If there is at least one, `w` is set to 1. If there are multiple, a random one is chosen.",
        "Added in Iris 1.2.5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "lightningBoltPosition",
      "type": "vec4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "The logical height of the current dimension, which refers to the maximum height to which chorus fruits and nether portals can bring players.",
        "Added in Iris 1.6"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "logicalHeightLimit",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Maximum player air value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "maxPlayerAir",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Maximum player armor value.",
        "Added in Iris 1.6.15"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "maxPlayerArmor",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Maximum player health value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "maxPlayerHealth",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Maximum player hunger value.",
        "Added in Iris 1.2.7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "maxPlayerHunger",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "xy = blockId, renderType        \"blockId\" is used only for blocks specified in \"block.properties\""
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "mc_Entity",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "st = midTexU, midTexV           Sprite middle UV coordinates"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "mc_midTexCoord",
      "type": "vec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "used by terrain chunks (with attribute \"vaPosition\") and clouds, replaces chunkOffset (1.21.2+)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "modelOffset",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "model view matrix"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "modelViewMatrix",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse model view matrix"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "modelViewMatrixInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0-7"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "moonPhase",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "moon position in eye space"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "moonPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "near viewing plane distance"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "near",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "night vision (0.0-1.0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "nightVision",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "15"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "noisetex",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "normal matrix"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "normalMatrix",
      "type": "mat3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "2"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "normals",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "World alligned direction the player model's body is facing (currently broken, reads the same value as playerLookVector).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "playerBodyVector",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "World alligned direction the player model's head is facing. Not affected by animations such as swimming.",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "playerLookVector",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "player mood (0.0-1.0), increases the longer a player stays underground"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "playerMood",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "last frame cameraPosition"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "previousCameraPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "projection matrix"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "projectionMatrix",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse projection matrix"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "projectionMatrixInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0.0-1.0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "rainStrength",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Measures the rainfall aspect of the biome as defined by Minecraft internally.",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "rainfall",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "World space offset from the player model's head position to the camera's position (cameraPosition - eyePosition).",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "relativeEyePosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "render stage, see \"Standard Macros\", \"J. Render stages\""
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "renderStage",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "screen brightness (0.0-1.0)"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "screenBrightness",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "waterShadowEnabled ? 5 : 4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadow",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0.0-1.0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowAngle",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "shadow light (sun or moon) position in eye space"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowLightPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "modelview matrix when the shadow map was generated"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowModelView",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse shadowModelView"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowModelViewInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "projection matrix when the shadow map was generated"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowProjection",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "inverse shadowProjection"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowProjectionInverse",
      "type": "mat4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "13"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowcolor",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "13"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowcolor0",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "14"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowcolor1",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowtex0",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "5"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "shadowtex1",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "r, g, b"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "skyColor",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "3"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "specular",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "sprite bounds in the texture atlas (u0, v0, u1, v1), set when MC_ANISOTROPIC_FILTERING is enabled"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "spriteBounds",
      "type": "vec4",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0.0-1.0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "sunAngle",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "sun position in eye space"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "sunPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Measures the temperature aspect of the biome as defined by Minecraft internally.",
        "Added in Iris 1.6.11"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "temperature",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "not used"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "terrainIconSize",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "not used"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "terrainTextureSize",
      "type": "ivec2",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "0"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "tex",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "Controls the \"thunder strength\", equivalent to Optifine's rainStrength for thunder.",
        "Added in Iris 1.3"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "thunderStrength",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "direction up"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "upPosition",
      "type": "vec3",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "color (r, g, b, a)1.17+"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaColor",
      "type": "vec4",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "normal (x, y, z)  1.17+"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaNormal",
      "type": "vec3",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "position (x, y, z)1.17+, for terrain it is relative to the chunk origin, see \"modelOffset\""
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaPosition",
      "type": "vec3",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "texture (u, v) 1.17+"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaUV0",
      "type": "vec2",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "overlay (u, v) 1.17+"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaUV1",
      "type": "ivec2",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "lightmap (u, v) 1.17+"
      ],
      "extensions": [],
      "modifiers": "in",
      "name": "vaUV2",
      "type": "ivec2",
      "versions": [
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "viewHeight"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "viewHeight",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "viewWidth"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "viewWidth",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "4"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "watershadow",
      "type": "sampler2D",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "rainStrength smoothed with wetnessHalfLife or drynessHalfLife"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "wetness",
      "type": "float",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "<days> = worldTicks / 24000"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "worldDay",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    },
    {
      "description": [
        "<ticks> = worldTicks % 24000"
      ],
      "extensions": [],
      "modifiers": "uniform",
      "name": "worldTime",
      "type": "int",
      "versions": [
        110,
        120,
        130,
        150,
        330,
        400,
        410,
        420,
        430,
        450
      ]
    }
  ],
  "functions": [
    {
      "return_type": "void",
      "name": "EmitMeshTasksEXT",
      "parameters": [
        {
          "type": "uint",
          "name": "groupCountX"
        },
        {
          "type": "uint",
          "name": "groupCountY"
        },
        {
          "type": "uint",
          "name": "groupCountZ"
        }
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "return_type": "void",
      "name": "EmitStreamVertex",
      "parameters": [
        {
          "type": "int",
          "name": "stream"
        }
      ],
      "description": [
        "_Available only in the Geometry Shader_, `EmitStreamVertex` emits the current values of output variables to the current output primitive on stream _stream_. The argument _stream_ must be a constant integral expression. On return from this call, the value of all output variables for all streams are undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "EmitVertex",
      "parameters": [],
      "description": [
        "_Available only in the Geometry Shader_, `EmitVertex` emits the current values of output variables to the current output primitive on the first (and possibly only) primitive stream. It is equivalent to calling EmitStreamVertex with _stream_ set to 0."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "EndPrimitive",
      "parameters": [],
      "description": [
        "_Available only in the Geometry Shader_, `EndPrimitive` completes the current output primitive on the first (and possibly only) vertex stream and starts a new one.No vertex is emitted. Calling `EndPrimitive` is equivalent to calling EndStreamPrimitive with _stream_ set to 0."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "EndStreamPrimitive",
      "parameters": [
        {
          "type": "int",
          "name": "stream"
        }
      ],
      "description": [
        "_Available only in the Geometry Shader_, `EndStreamPrimitive` completes the current output primitive on stream _stream_ and starts a new one. The argument to _stream_ must be a constant integral expression. No vertex is emitted."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "abs",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`abs` returns the absolute value of _x_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "abs",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        }
      ],
      "description": [
        "`abs` returns the absolute value of _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "abs",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`abs` returns the absolute value of _x_."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "acos",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`acos` returns the angle whose trigonometric cosine is `x`. The range of values returned by `acos` is ` [0 π] `. The result is undefined if `| x | > 1`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "acosh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`acosh` returns the arc hyperbolic cosine of `x`; the non-negative inverse of cosh. Results are undefined if `x < 1`."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bool",
      "name": "all",
      "parameters": [
        {
          "type": "bvec",
          "name": "x"
        }
      ],
      "description": [
        "`all` returns true if all elements of _x_ are true and false otherwise. It is functionally equivalent to:",
        "",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bool",
      "name": "any",
      "parameters": [
        {
          "type": "bvec",
          "name": "x"
        }
      ],
      "description": [
        "`any` returns true if any element of _x_ is true and false otherwise. It is functionally equivalent to:",
        "",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "asin",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`atan` returns the angle whose trigonometric sine is `x`. The range of values returned by `asin` is ` [− π / 2 π / 2] `. The result is undefined if `| x | > 1`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "asinh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`asinh` returns the arc hyperbolic sine of `x`; the inverse of sinh."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "atan",
      "parameters": [
        {
          "type": "genType",
          "name": "y"
        },
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`atan` returns the angle whose trigonometric arctangent is ` y / x ` or `y_over_x`, depending on which overload is invoked. In the first overload, the signs of `y` and `x` are used to determine the quadrant that the angle lies in. The values returned by `atan` in this case are in the range ` [− π π] `. Results are undefined if `x` is zero.",
        "For the second overload, `atan` returns the angle whose tangent is `y_over_x`. Values returned in this case are in the range ` [− π / 2 π / 2] `."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "atan",
      "parameters": [
        {
          "type": "genType",
          "name": "y_over_x"
        }
      ],
      "description": [
        "`atan` returns the angle whose trigonometric arctangent is ` y / x ` or `y_over_x`, depending on which overload is invoked. In the first overload, the signs of `y` and `x` are used to determine the quadrant that the angle lies in. The values returned by `atan` in this case are in the range ` [− π π] `. Results are undefined if `x` is zero.",
        "For the second overload, `atan` returns the angle whose tangent is `y_over_x`. Values returned in this case are in the range ` [− π / 2 π / 2] `."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "atanh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`atanh` returns the arc hyperbolic tangent of `x`; the inverse of tanh. Results are undefined if `| x | > 1`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "atomicAdd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicAdd` performs an atomic addition of _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the addition occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicAdd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicAdd` performs an atomic addition of _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the addition occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicAdd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "float16_t",
      "name": "atomicAdd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float16_t",
          "name": "mem"
        },
        {
          "type": "float16_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "float",
      "name": "atomicAdd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicAnd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicAnd` performs an atomic logical AND with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicAnd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicAnd` performs an atomic logical AND with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicAnd",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicCompSwap",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicCompSwap` performs an atomic comparison of _compare_ with the contents of _mem_. If the content of _mem_ is equal to _compare_, then the content of _data_ is written into _mem_, otherwise the content of _mem_ is unmodifed. The function returns the original content of _mem_ regardless of the outcome of the comparison. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicCompSwap",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicCompSwap` performs an atomic comparison of _compare_ with the contents of _mem_. If the content of _mem_ is equal to _compare_, then the content of _data_ is written into _mem_, otherwise the content of _mem_ is unmodifed. The function returns the original content of _mem_ regardless of the outcome of the comparison. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicCompSwap",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "compare"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicCounter",
      "parameters": [
        {
          "type": "atomic_uint",
          "name": "c"
        }
      ],
      "description": [
        "`atomicCounter` returns the current value of of the atomic counter _c_."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicCounterDecrement",
      "parameters": [
        {
          "type": "atomic_uint",
          "name": "c"
        }
      ],
      "description": [
        "`atomicCounterDecrement` atomically decrements the value of the atomic counter _c_ and returns its new value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicCounterIncrement",
      "parameters": [
        {
          "type": "atomic_uint",
          "name": "c"
        }
      ],
      "description": [
        "`atomicCounterIncrement` atomically increments the value of the atomic counter _c_ and returns its prior value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "atomicExchange",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicExchange` performs an atomic exhange of _data_ with the contents of _mem_. The content of _data_ is written into _mem_ and the original contents of _mem_ are returned. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicExchange",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicExchange` performs an atomic exhange of _data_ with the contents of _mem_. The content of _data_ is written into _mem_ and the original contents of _mem_ are returned. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicExchange",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "float16_t",
      "name": "atomicExchange",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float16_t",
          "name": "mem"
        },
        {
          "type": "float16_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "float",
      "name": "atomicExchange",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float"
      ]
    },
    {
      "return_type": "float16_t",
      "name": "atomicLoad",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float16_t",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "scope"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "float",
      "name": "atomicLoad",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "scope"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicMax",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicMax` performs an atomic comparison of _data_ to the contents of _mem_, writes the maximum value into _mem_ and returns the original contents of _mem_ from before the comparison occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicMax",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicMax` performs an atomic comparison of _data_ to the contents of _mem_, writes the maximum value into _mem_ and returns the original contents of _mem_ from before the comparison occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicMax",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "float",
      "name": "atomicMax",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicMin",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicMin` performs an atomic comparison of _data_ to the contents of _mem_, writes the minimum value into _mem_ and returns the original contents of _mem_ from before the comparison occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicMin",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicMin` performs an atomic comparison of _data_ to the contents of _mem_, writes the minimum value into _mem_ and returns the original contents of _mem_ from before the comparison occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicMin",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "float",
      "name": "atomicMin",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicOr",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicOr` performs an atomic logical OR with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicOr",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicOr` performs an atomic logical OR with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "atomicStore",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float16_t",
          "name": "mem"
        },
        {
          "type": "float16_t",
          "name": "data"
        },
        {
          "type": "int",
          "name": "scope"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float2"
      ]
    },
    {
      "return_type": "void",
      "name": "atomicStore",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "float",
          "name": "mem"
        },
        {
          "type": "float",
          "name": "data"
        },
        {
          "type": "int",
          "name": "scope"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_float"
      ]
    },
    {
      "return_type": "int",
      "name": "atomicXor",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "int",
          "name": "mem"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`atomicXor` performs an atomic logical exclusive OR with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "atomicXor",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint",
          "name": "mem"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`atomicXor` performs an atomic logical exclusive OR with _data_ to the contents of _mem_ and returns the original contents of _mem_ from before the logical operation occured. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.",
        "Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "atomicXor",
      "parameters": [
        {
          "modifiers": "inout",
          "type": "uint64_t",
          "name": "mem"
        },
        {
          "type": "uint64_t",
          "name": "data"
        }
      ],
      "extensions": [
        "GL_EXT_shader_atomic_int64"
      ]
    },
    {
      "return_type": "void",
      "name": "barrier",
      "parameters": [],
      "description": [
        "_Available only in the Tessellation Control and Compute Shaders_, `barrier` provides a partially defined order of execution between shader invocations. For any given static instance of `barrier`, in a tessellation control shader, all invocations for a single input patch must enter it before any will be allowed to continue beyond it. For any given static instance of `barrier` in a compute shader, all invocations within a single work group must enter it before any are allowed to continue beyond it. This ensures that values written by one invocation prior to a given static instance of `barrier` can be safely read by other invocations after their call to the same static instance of `barrier`. Because invocations may execute in undefined order between these `barrier` calls, the values of a per-vertex or per-patch output variable, or any shared variable will be undefined in a number of cases.",
        "`barrier` may only be placed inside the function `main()` of the tessellation control shader, but may be placed anywhere in a compute shader. Calls to `barrier` may not be placed within any control flow. Barriers are also disallowed after a return statement in the function `main()`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "barrier",
      "parameters": [],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "genIType",
      "name": "bitCount",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "`bitCount` returns the number of bits that are set to 1 in the binary representation of _value_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "bitCount",
      "parameters": [
        {
          "type": "genUType",
          "name": "value"
        }
      ],
      "description": [
        "`bitCount` returns the number of bits that are set to 1 in the binary representation of _value_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "bitfieldExtract",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "type": "int",
          "name": "bits"
        }
      ],
      "description": [
        "`bitfieldExtract` extracts a subset of the bits of _value_ and returns it in the least significant bits of the result. The range of bits extracted is [_offset_, _offset_ + _bits_ + 1].",
        "For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit _offset_ + _base_ - 1 (i.e., it is _sign extended_ to the width of the return type).",
        "If _bits_ is zero, the result will be zero. The result will be undefined if _offset_ or _bits_ is negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used to store the operand."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "bitfieldExtract",
      "parameters": [
        {
          "type": "genUType",
          "name": "value"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "type": "int",
          "name": "bits"
        }
      ],
      "description": [
        "`bitfieldExtract` extracts a subset of the bits of _value_ and returns it in the least significant bits of the result. The range of bits extracted is [_offset_, _offset_ + _bits_ + 1].",
        "For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit _offset_ + _base_ - 1 (i.e., it is _sign extended_ to the width of the return type).",
        "If _bits_ is zero, the result will be zero. The result will be undefined if _offset_ or _bits_ is negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used to store the operand."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "bitfieldInsert",
      "parameters": [
        {
          "type": "genIType",
          "name": "base"
        },
        {
          "type": "genIType",
          "name": "insert"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "type": "int",
          "name": "bits"
        }
      ],
      "description": [
        "`bitfieldInsert` inserts the _bits_ least significant bits of _insert_ into _base_ at offset _offset_. The returned value will have bits [_offset_, _offset_ + _bits_ + 1] taken from [0, _bits_ - 1] of _insert_ and all other bits taken directly from the corresponding bits of _base_. If _bits_ is zero, the result will simply be the original value of _base_. The result will be undefined if _offset_ or _bits_ is negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used to store the operand."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "bitfieldInsert",
      "parameters": [
        {
          "type": "genUType",
          "name": "base"
        },
        {
          "type": "genUType",
          "name": "insert"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "type": "int",
          "name": "bits"
        }
      ],
      "description": [
        "`bitfieldInsert` inserts the _bits_ least significant bits of _insert_ into _base_ at offset _offset_. The returned value will have bits [_offset_, _offset_ + _bits_ + 1] taken from [0, _bits_ - 1] of _insert_ and all other bits taken directly from the corresponding bits of _base_. If _bits_ is zero, the result will simply be the original value of _base_. The result will be undefined if _offset_ or _bits_ is negative, or if the sum of _offset_ and _bits_ is greater than the number of bits used to store the operand."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "bitfieldReverse",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "`bitfieldReverse` returns the reversal of the bits of value. The bit numbered _n_ will be taken from bit (_bits_ - 1) - _n_ of _value_, where _bits_ is the total number of bits used to represent _value_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "bitfieldReverse",
      "parameters": [
        {
          "type": "genUType",
          "name": "value"
        }
      ],
      "description": [
        "`bitfieldReverse` returns the reversal of the bits of value. The bit numbered _n_ will be taken from bit (_bits_ - 1) - _n_ of _value_, where _bits_ is the total number of bits used to represent _value_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "ceil",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`ceil` returns a value equal to the nearest integer that is greater than or equal to _x_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "ceil",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`ceil` returns a value equal to the nearest integer that is greater than or equal to _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "minVal"
        },
        {
          "type": "genType",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "float",
          "name": "minVal"
        },
        {
          "type": "float",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "minVal"
        },
        {
          "type": "genDType",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "double",
          "name": "minVal"
        },
        {
          "type": "double",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "minVal"
        },
        {
          "type": "genIType",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "int",
          "name": "minVal"
        },
        {
          "type": "int",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "minVal"
        },
        {
          "type": "genUType",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "clamp",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "uint",
          "name": "minVal"
        },
        {
          "type": "uint",
          "name": "maxVal"
        }
      ],
      "description": [
        "`clamp` returns the value of _x_ constrained to the range _minVal_ to _maxVal_. The returned value is computed as min(max(_x_, _minVal_), _maxVal_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uvec2",
      "name": "clockRealtime2x32EXT",
      "parameters": [],
      "extensions": [
        "GL_EXT_shader_realtime_clock"
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "clockRealtimeEXT",
      "parameters": [],
      "extensions": [
        "GL_EXT_shader_realtime_clock"
      ]
    },
    {
      "return_type": "gvec4",
      "name": "colorAttachmentReadEXT",
      "parameters": [
        {
          "type": "gattachment",
          "name": "attachment"
        }
      ],
      "extensions": [
        "GL_EXT_shader_tile_image"
      ]
    },
    {
      "return_type": "vec3",
      "name": "computeDir",
      "parameters": [
        {
          "type": "vec3",
          "name": "inDir"
        }
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "void",
      "name": "controlBarrier",
      "parameters": [
        {
          "type": "int",
          "name": "execution"
        },
        {
          "type": "int",
          "name": "memory"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "genType",
      "name": "cos",
      "parameters": [
        {
          "type": "genType",
          "name": "angle"
        }
      ],
      "description": [
        "`cos` returns the trigonometric cosine of _angle_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "cosh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`cosh` returns the hyperbolic cosine of `x`. The hyperbolic cosine of `x` is computed as ` e**x + e** − x / 2 `."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec3",
      "name": "cross",
      "parameters": [
        {
          "type": "vec3",
          "name": "x"
        },
        {
          "type": "vec3",
          "name": "y"
        }
      ],
      "description": [
        "`cross` returns the cross product of two vectors, _x_ and _y_. i.e.,",
        "```\n x  [  1  ]  ⋅  y  [  2  ]  −  y  [  1  ]  ⋅  x  [  2  ]   \n x  [  2  ]  ⋅  y  [  0  ]  −  y  [  2  ]  ⋅  x  [  0  ]   \n x  [  0  ]  ⋅  y  [  1  ]  −  y  [  0  ]  ⋅  x  [  1  ]   \n\n```\n"
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dvec3",
      "name": "cross",
      "parameters": [
        {
          "type": "dvec3",
          "name": "x"
        },
        {
          "type": "dvec3",
          "name": "y"
        }
      ],
      "description": [
        "`cross` returns the cross product of two vectors, _x_ and _y_. i.e.,",
        "```\n x  [  1  ]  ⋅  y  [  2  ]  −  y  [  1  ]  ⋅  x  [  2  ]   \n x  [  2  ]  ⋅  y  [  0  ]  −  y  [  2  ]  ⋅  x  [  0  ]   \n x  [  0  ]  ⋅  y  [  1  ]  −  y  [  0  ]  ⋅  x  [  1  ]   \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdx",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdxCoarse",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdxFine",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdy",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdyCoarse",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "dFdyFine",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the partial derivative of expression _p_ with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).",
        "`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on on the value of _p_ for the current fragment and its immediate neighbor(s).",
        "`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of _p_ for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.",
        "`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.",
        "Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression _p_ is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "degrees",
      "parameters": [
        {
          "type": "genType",
          "name": "radians"
        }
      ],
      "description": [
        "`degrees` converts a quantity, specified in radians into degrees. That is, the return value is ` 180 ⋅ radians / π `."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "determinant",
      "parameters": [
        {
          "type": "mat2",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "determinant",
      "parameters": [
        {
          "type": "mat3",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "determinant",
      "parameters": [
        {
          "type": "mat4",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "determinant",
      "parameters": [
        {
          "type": "dmat2",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "determinant",
      "parameters": [
        {
          "type": "dmat3",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "determinant",
      "parameters": [
        {
          "type": "dmat4",
          "name": "m"
        }
      ],
      "description": [
        "`determinant` returns the determinant of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "distance",
      "parameters": [
        {
          "type": "genType",
          "name": "p0"
        },
        {
          "type": "genType",
          "name": "p1"
        }
      ],
      "description": [
        "`distance` returns the distance between the two points _p0_ and _p1_. i.e., `length(_p0_, _p1_);`"
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "distance",
      "parameters": [
        {
          "type": "genDType",
          "name": "p0"
        },
        {
          "type": "genDType",
          "name": "p1"
        }
      ],
      "description": [
        "`distance` returns the distance between the two points _p0_ and _p1_. i.e., `length(_p0_, _p1_);`"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "dot",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        }
      ],
      "description": [
        "`dot` returns the dot product of two vectors, _x_ and _y_. i.e., ` x [ 0 ] ⋅ y [ 0 ] + x [ 1 ] ⋅ y [ 1 ] + ... `"
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "dot",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        }
      ],
      "description": [
        "`dot` returns the dot product of two vectors, _x_ and _y_. i.e., ` x [ 0 ] ⋅ y [ 0 ] + x [ 1 ] ⋅ y [ 1 ] + ... `"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genI64Type",
      "name": "doubleBitsToInt64",
      "parameters": [
        {
          "type": "genDType",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genU64Type",
      "name": "doubleBitsToUint64",
      "parameters": [
        {
          "type": "genDType",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "bvec",
      "name": "equal",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`equal` returns a boolean vector in which each element _i_ is computed as _x_[_i_] == _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "equal",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`equal` returns a boolean vector in which each element _i_ is computed as _x_[_i_] == _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "equal",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`equal` returns a boolean vector in which each element _i_ is computed as _x_[_i_] == _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "executeCallableNV",
      "parameters": [
        {
          "type": "uint",
          "name": "sbtRecordIndex"
        },
        {
          "type": "int",
          "name": "callable"
        }
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "genType",
      "name": "exp",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`exp` returns the natural exponentiation of _x_. i.e., `e**x`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "exp2",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`exp2` returns 2 raised to the power of _x_. i.e., `2**x`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "faceforward",
      "parameters": [
        {
          "type": "genType",
          "name": "N"
        },
        {
          "type": "genType",
          "name": "I"
        },
        {
          "type": "genType",
          "name": "Nref"
        }
      ],
      "description": [
        "`faceforward` orients a vector to point away from a surface as defined by its normal. If dot`(_Nref_, _I_) < 0` `faceforward` returns _N_, otherwise it returns `-_N_`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "faceforward",
      "parameters": [
        {
          "type": "genDType",
          "name": "N"
        },
        {
          "type": "genDType",
          "name": "I"
        },
        {
          "type": "genDType",
          "name": "Nref"
        }
      ],
      "description": [
        "`faceforward` orients a vector to point away from a surface as defined by its normal. If dot`(_Nref_, _I_) < 0` `faceforward` returns _N_, otherwise it returns `-_N_`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "fetchMicroTriangleVertexBarycentricNV",
      "parameters": [
        {
          "type": "accelerationStructureEXT",
          "name": "as"
        },
        {
          "type": "int",
          "name": "instanceId"
        },
        {
          "type": "int",
          "name": "geometryIndex"
        },
        {
          "type": "int",
          "name": "primitiveIndex"
        },
        {
          "type": "ivec2",
          "name": "barycentrics"
        }
      ],
      "extensions": [
        "GL_NV_displacement_micromap"
      ]
    },
    {
      "return_type": "vec3",
      "name": "fetchMicroTriangleVertexPositionNV",
      "parameters": [
        {
          "type": "accelerationStructureEXT",
          "name": "as"
        },
        {
          "type": "int",
          "name": "instanceId"
        },
        {
          "type": "int",
          "name": "geometryIndex"
        },
        {
          "type": "int",
          "name": "primitiveIndex"
        },
        {
          "type": "ivec2",
          "name": "barycentrics"
        }
      ],
      "extensions": [
        "GL_NV_displacement_micromap"
      ]
    },
    {
      "return_type": "genIType",
      "name": "findLSB",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "`findLSB` returns the bit number of the least significant bit that is set to 1 in the binary representation of _value_. If _value_ is zero, -1 will be returned."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "findLSB",
      "parameters": [
        {
          "type": "genUType",
          "name": "value"
        }
      ],
      "description": [
        "`findLSB` returns the bit number of the least significant bit that is set to 1 in the binary representation of _value_. If _value_ is zero, -1 will be returned."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "findMSB",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "`findMSB` returns the bit number of the most significant bit that is set to 1 in the binary representation of _value_. For positive integers, the result will be the bit number of the most significant bit that is set to 1. For negative integers, the result will be the bit number of the most significant bit set to 0. For a _value_ of zero or negative 1, -1 will be returned."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "findMSB",
      "parameters": [
        {
          "type": "genUType",
          "name": "value"
        }
      ],
      "description": [
        "`findMSB` returns the bit number of the most significant bit that is set to 1 in the binary representation of _value_. For positive integers, the result will be the bit number of the most significant bit that is set to 1. For negative integers, the result will be the bit number of the most significant bit set to 0. For a _value_ of zero or negative 1, -1 will be returned."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genI16Type",
      "name": "float16BitsToInt16",
      "parameters": [
        {
          "type": "genF16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genU16Type",
      "name": "float16BitsToUint16",
      "parameters": [
        {
          "type": "genF16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genIType",
      "name": "floatBitsToInt",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`floatBitsToInt` and `floatBitsToUint` return the encoding of their floating-point parameters as `int` or `uint`, respectively. The floating-point bit-level representation is preserved."
      ],
      "versions": [
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genI32Type",
      "name": "floatBitsToInt",
      "parameters": [
        {
          "type": "genF32Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genUType",
      "name": "floatBitsToUint",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`floatBitsToInt` and `floatBitsToUint` return the encoding of their floating-point parameters as `int` or `uint`, respectively. The floating-point bit-level representation is preserved."
      ],
      "versions": [
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genU32Type",
      "name": "floatBitsToUint",
      "parameters": [
        {
          "type": "genF32Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genType",
      "name": "floor",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`floor` returns a value equal to the nearest integer that is less than or equal to _x_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "floor",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`floor` returns a value equal to the nearest integer that is less than or equal to _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "fma",
      "parameters": [
        {
          "type": "genType",
          "name": "a"
        },
        {
          "type": "genType",
          "name": "b"
        },
        {
          "type": "genType",
          "name": "c"
        }
      ],
      "description": [
        "`fma` performs, where possible, a fused multiply-add operation, returning `a * b + c`. In use cases where the return value is eventually consumed by a variable declared as `precise`:",
        "`fma`() is considered a single operation, whereas the expression `a * b + c` consumed by a variable declared as `precise` is considered two operations.",
        "The precision of `fma`() can differ from the precision of the expression `a * b + c`.",
        "`fma`() will be computed with the same precision as any other `fma`() consumed by a `precise` variable, giving invariant results for the same input values of _a_, _b_ and _c_.",
        "Otherwise, in the absense of `precise` consumption, there are no special constraints on the number of operations or difference in precision between `fma`() and the expression `a * b + c`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "fma",
      "parameters": [
        {
          "type": "genDType",
          "name": "a"
        },
        {
          "type": "genDType",
          "name": "b"
        },
        {
          "type": "genDType",
          "name": "c"
        }
      ],
      "description": [
        "`fma` performs, where possible, a fused multiply-add operation, returning `a * b + c`. In use cases where the return value is eventually consumed by a variable declared as `precise`:",
        "`fma`() is considered a single operation, whereas the expression `a * b + c` consumed by a variable declared as `precise` is considered two operations.",
        "The precision of `fma`() can differ from the precision of the expression `a * b + c`.",
        "`fma`() will be computed with the same precision as any other `fma`() consumed by a `precise` variable, giving invariant results for the same input values of _a_, _b_ and _c_.",
        "Otherwise, in the absense of `precise` consumption, there are no special constraints on the number of operations or difference in precision between `fma`() and the expression `a * b + c`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "fract",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`fract` returns the fractional part of _x_. This is calculated as _x_ - floor(_x_)."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "fract",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`fract` returns the fractional part of _x_. This is calculated as _x_ - floor(_x_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "fragmentFetchAMD",
      "parameters": [
        {
          "type": "gsampler2DMS",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "fragIndex"
        }
      ],
      "description": [
        "Fetches a color fragment with a     \n corresponding fragment mask value."
      ],
      "extensions": [
        "GL_AMD_shader_fmask"
      ]
    },
    {
      "return_type": "uint",
      "name": "fragmentMaskFetchAMD",
      "parameters": [
        {
          "type": "gsampler2DMS",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        }
      ],
      "description": [
        "Returns the fragment mask from a    \n multisampled color image. The       \n fragment mask is a single uint where\n each subsequent 4 bit specifies the \n color fragment index corresponding  \n to the color sample, starting from  \n the least significant bit."
      ],
      "extensions": [
        "GL_AMD_shader_fmask"
      ]
    },
    {
      "return_type": "genType",
      "name": "frexp",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "modifiers": "out",
          "type": "genIType",
          "name": "exp"
        }
      ],
      "description": [
        "`frexp` extracts _x_ into a floating-point significand in the range [0.5, 1.0) and in integral exponent of two, such that:",
        "` x = significand ⋅ 2**exponent `",
        "The significand is returned by the function and the exponent is returned in the output parameter _exp_. For a floating-point value of zero, the significand and exponent are both zero. For a floating-point value that is an infinity or a floating-point NaN, the results are undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "frexp",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "modifiers": "out",
          "type": "genIType",
          "name": "exp"
        }
      ],
      "description": [
        "`frexp` extracts _x_ into a floating-point significand in the range [0.5, 1.0) and in integral exponent of two, such that:",
        "` x = significand ⋅ 2**exponent `",
        "The significand is returned by the function and the exponent is returned in the output parameter _exp_. For a floating-point value of zero, the significand and exponent are both zero. For a floating-point value that is an infinity or a floating-point NaN, the results are undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genFType",
      "name": "frexp",
      "parameters": [
        {
          "type": "genFType",
          "name": "x"
        },
        {
          "modifiers": "out",
          "type": "genI32Type",
          "name": "exp"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genType",
      "name": "fwidth",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument _p_. `fwidth` is equivalent to ` abs(_dFdx_(p)) + abs(_dFdy_(p)) `. `fwidthCoarse` is equivalent to ` abs(_dFdxCoarse_(p)) + abs(_dFdyCoarse_(p)) `. `fwidthFine` is equivalent to ` abs(_dFdxFine_(p)) + abs(_dFdyFine_(p)) `."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "fwidthCoarse",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument _p_. `fwidth` is equivalent to ` abs(_dFdx_(p)) + abs(_dFdy_(p)) `. `fwidthCoarse` is equivalent to ` abs(_dFdxCoarse_(p)) + abs(_dFdyCoarse_(p)) `. `fwidthFine` is equivalent to ` abs(_dFdxFine_(p)) + abs(_dFdyFine_(p)) `."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "fwidthFine",
      "parameters": [
        {
          "type": "genType",
          "name": "p"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument _p_. `fwidth` is equivalent to ` abs(_dFdx_(p)) + abs(_dFdy_(p)) `. `fwidthCoarse` is equivalent to ` abs(_dFdxCoarse_(p)) + abs(_dFdyCoarse_(p)) `. `fwidthFine` is equivalent to ` abs(_dFdxFine_(p)) + abs(_dFdyFine_(p)) `."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThan",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] > _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThan",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] > _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThan",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] > _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThanEqual",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≥ _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThanEqual",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≥ _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "greaterThanEqual",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`greaterThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≥ _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "groupMemoryBarrier",
      "parameters": [],
      "description": [
        "`groupMemoryBarrier` waits on the completion of all memory accesses performed by an invocation of a compute shader relative to the same access performed by other invocations in the same work group and then returns with no other effect."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "groupMemoryBarrier",
      "parameters": [],
      "description": [
        "(modify last paragraph, p. 187)",
        "... all of the above variable types. The functions `memoryBarrierShared()`\nand `groupMemoryBarrier()` are available only in compute, task, and mesh\nshaders; the other functions are available in all shader types.",
        "(modify last paragraph, p. 188)",
        "... When using the function `groupMemoryBarrier()`, this ordering guarantee\napplies only to other shader invocations in the same compute, task, or\nmesh shader workgroup; all other memory barrier functions provide the\nguarantee to all other shader invocations. ..."
      ],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "return_type": "void",
      "name": "groupMemoryBarrier",
      "parameters": [],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "void",
      "name": "groupMemoryBarrier",
      "parameters": [],
      "description": [
        "(modify last paragraph, p. 187)",
        "... all of the above variable types. The functions `memoryBarrierShared()`\nand `groupMemoryBarrier()` are available only in compute, task, and mesh\nshaders; the other functions are available in all shader types.",
        "(modify last paragraph, p. 188)",
        "... When using the function `groupMemoryBarrier()`, this ordering guarantee\napplies only to other shader invocations in the same compute, task, or\nmesh shader work group; all other memory barrier functions provide the\nguarantee to all other shader invocations. ..."
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "return_type": "genI16Type",
      "name": "halfBitsToInt16",
      "parameters": [
        {
          "type": "genF16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genU16Type",
      "name": "halfBitsToUInt16",
      "parameters": [
        {
          "type": "genF16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectExecuteShaderNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        },
        {
          "type": "int",
          "name": "payload"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectGetAttributesNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        },
        {
          "type": "int",
          "name": "attributeLocation"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "float",
      "name": "hitObjectGetCurrentTimeNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "int",
      "name": "hitObjectGetGeometryIndexNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "uint",
      "name": "hitObjectGetHitKindNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "int",
      "name": "hitObjectGetInstanceCustomIndexNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "int",
      "name": "hitObjectGetInstanceIdNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "vec3",
      "name": "hitObjectGetObjectRayDirectionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "vec3",
      "name": "hitObjectGetObjectRayOriginNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "hitObjectGetObjectToWorldNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "int",
      "name": "hitObjectGetPrimitiveIndexNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "float",
      "name": "hitObjectGetRayTMaxNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "float",
      "name": "hitObjectGetRayTMinNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "uint",
      "name": "hitObjectGetShaderBindingTableRecordIndexNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "uvec2",
      "name": "hitObjectGetShaderRecordBufferHandleNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "vec3",
      "name": "hitObjectGetWorldRayDirectionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "vec3",
      "name": "hitObjectGetWorldRayOriginNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "hitObjectGetWorldToObjectNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "bool",
      "name": "hitObjectIsEmptyNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "bool",
      "name": "hitObjectIsHitNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "bool",
      "name": "hitObjectIsMissNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordEmptyNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordHitMotionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitobject"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "int",
          "name": "instanceid"
        },
        {
          "type": "int",
          "name": "primitiveid"
        },
        {
          "type": "int",
          "name": "geometryindex"
        },
        {
          "type": "uint",
          "name": "hitKind"
        },
        {
          "type": "uint",
          "name": "sbtRecordOffset"
        },
        {
          "type": "uint",
          "name": "sbtRecordStride"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "float",
          "name": "currentTime"
        },
        {
          "type": "int",
          "name": "attributeLocation"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordHitNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitobject"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "int",
          "name": "instanceid"
        },
        {
          "type": "int",
          "name": "primitiveid"
        },
        {
          "type": "int",
          "name": "geometryindex"
        },
        {
          "type": "uint",
          "name": "hitKind"
        },
        {
          "type": "uint",
          "name": "sbtRecordOffset"
        },
        {
          "type": "uint",
          "name": "sbtRecordStride"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "int",
          "name": "attributeLocation"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordHitWithIndexMotionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitobject"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "int",
          "name": "instanceid"
        },
        {
          "type": "int",
          "name": "primitiveid"
        },
        {
          "type": "int",
          "name": "geometryindex"
        },
        {
          "type": "uint",
          "name": "hitKind"
        },
        {
          "type": "uint",
          "name": "sbtRecordIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "float",
          "name": "currentTime"
        },
        {
          "type": "int",
          "name": "attributeLocation"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordHitWithIndexNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitobject"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "int",
          "name": "instanceid"
        },
        {
          "type": "int",
          "name": "primitiveid"
        },
        {
          "type": "int",
          "name": "geometryindex"
        },
        {
          "type": "uint",
          "name": "hitKind"
        },
        {
          "type": "uint",
          "name": "sbtRecordIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "int",
          "name": "attributeLocation"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordMissMotionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        },
        {
          "type": "uint",
          "name": "sbtRecordIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "TMax"
        },
        {
          "type": "float",
          "name": "currentTime"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectRecordMissNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitObject"
        },
        {
          "type": "uint",
          "name": "sbtRecordIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "TMax"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "hitObjectTraceRayMotionNV",
      "parameters": [
        {
          "type": "hitObjectNV",
          "name": "hitobject"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "uint",
          "name": "rayFlags"
        },
        {
          "type": "uint",
          "name": "cullMask"
        },
        {
          "type": "uint",
          "name": "sbtRecordOffset"
        },
        {
          "type": "uint",
          "name": "sbtRecordStride"
        },
        {
          "type": "uint",
          "name": "missIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "float",
          "name": "currentTime"
        },
        {
          "type": "int",
          "name": "payload"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "void",
      "name": "ignoreIntersectionNV",
      "parameters": [],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAdd",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAdd` atomically computes a new value by adding the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicAnd",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicAnd` atomically computes a new value by logically ANDing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "compare"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicCompSwap",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "compare"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicCompSwap` atomically compares the value of _compare_ with that of the texel at coordinate _P_ and _sample_ (for multisampled forms) in the image bound to uint _image_. If the values are equal, _data_ is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicExchange",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "float",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicExchange` atomically stores the value of _data_ into the texel at coordinate _P_ and _sample_ in the image bound to unit _image_, and returns the original value of the texel."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMax",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMax` atomically computes a new value by finding the maximum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicMin",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicMin` atomically computes a new value by finding the minimum of the value of _data_ and the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicOr",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicOr` atomically computes a new value by logically ORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "uint",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageAtomicXor",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "int",
          "name": "data"
        }
      ],
      "description": [
        "`imageAtomicXor` atomically computes a new value by logically XORing the value of _data_ to the contents of the texel at coordinate _P_ and _sample_ in the image bound to uint _image_, stores that value into the image and returns the original value."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`imageLoad` loads the texel at the coordinate _P_ from the image unit _image_. For multi-sample loads, the sample number is given by _sample_. When _image_, _P_, _sample_ identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "u64vec4",
      "name": "imageLoad",
      "parameters": [
        {
          "type": "readonly",
          "name": "IMAGE64_PARAMS"
        }
      ],
      "extensions": [
        "GL_EXT_shader_image_int64"
      ]
    },
    {
      "return_type": "int",
      "name": "imageSamples",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        }
      ],
      "description": [
        "`imageSamples` returns the number of samples per texel of the image bound to _image_."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageSamples",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        }
      ],
      "description": [
        "`imageSamples` returns the number of samples per texel of the image bound to _image_."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimageRect",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimageBuffer",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "imageSize",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        }
      ],
      "description": [
        "`imageSize` returns the dimensions of the image bound to _image_. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage1D",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage2D",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage3D",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage2DRect",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimageCube",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gbufferImage",
          "name": "image"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage1DArray",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage2DArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimageCubeArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage2DMS",
          "name": "image"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "gimage2DMSArray",
          "name": "image"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "sample"
        },
        {
          "type": "gvec4",
          "name": "data"
        }
      ],
      "description": [
        "`imageStore` stores _data_ into the texel at the coordinate _P_ from the image specified by _image_. For multi-sample stores, the sample number is given by _sample_. When _image_, _P_, and _sample_ identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "imageStore",
      "parameters": [
        {
          "type": "writeonly",
          "name": "IMAGE64_PARAMS"
        }
      ],
      "extensions": [
        "GL_EXT_shader_image_int64"
      ]
    },
    {
      "return_type": "void",
      "name": "imulExtended",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "y"
        },
        {
          "modifiers": "out",
          "type": "genIType",
          "name": "msb"
        },
        {
          "modifiers": "out",
          "type": "genIType",
          "name": "lsb"
        }
      ],
      "description": [
        "`umulExtended` and `imulExtended` perform multiplication of the two 32-bit integer quantities _x_ and _y_, producing a 64-bit integer result. The 32 least significant bits of this product are returned in _lsb_ and the 32 most significant bits are returned in _msb_. `umulExtended` and `imulExtended` perform unsigned and signed multiplication, respectively."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genF16Type",
      "name": "int16BitsToFloat16",
      "parameters": [
        {
          "type": "genI16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genF16Type",
      "name": "int16BitsToHalf",
      "parameters": [
        {
          "type": "genI16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genDType",
      "name": "int64BitsToDouble",
      "parameters": [
        {
          "type": "genI64Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genType",
      "name": "intBitsToFloat",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        }
      ],
      "description": [
        "`intBitsToFloat` and `uintBitsToFloat` return the encoding passed in parameter _x_ as a floating-point value. If the encoding of a NaN is passed in _x_, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter _x_, the resulting floating-point value is the corresponding (positive or negative) floating point infinity."
      ],
      "versions": [
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genF32Type",
      "name": "intBitsToFloat",
      "parameters": [
        {
          "type": "genI32Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "float",
      "name": "interpolateAtCentroid",
      "parameters": [
        {
          "type": "float",
          "name": "interpolant"
        }
      ],
      "description": [
        "`interpolateAtCentroid` returns the value of the input varying _interpolant_ sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the `centroid` qualifier."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "interpolateAtCentroid",
      "parameters": [
        {
          "type": "vec2",
          "name": "interpolant"
        }
      ],
      "description": [
        "`interpolateAtCentroid` returns the value of the input varying _interpolant_ sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the `centroid` qualifier."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec3",
      "name": "interpolateAtCentroid",
      "parameters": [
        {
          "type": "vec3",
          "name": "interpolant"
        }
      ],
      "description": [
        "`interpolateAtCentroid` returns the value of the input varying _interpolant_ sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the `centroid` qualifier."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "interpolateAtCentroid",
      "parameters": [
        {
          "type": "vec4",
          "name": "interpolant"
        }
      ],
      "description": [
        "`interpolateAtCentroid` returns the value of the input varying _interpolant_ sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the `centroid` qualifier."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "interpolateAtOffset",
      "parameters": [
        {
          "type": "float",
          "name": "interpolant"
        },
        {
          "type": "vec2",
          "name": "offset"
        }
      ],
      "description": [
        "`interpolateAtOffset` returns the value of the input varying _interpolant_ sampled at an offset from the center of the pixel specified by _offset_. The two floating-point components of _offset_ give the offset in pixels in the _x_ and _y_ directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "interpolateAtOffset",
      "parameters": [
        {
          "type": "vec2",
          "name": "interpolant"
        },
        {
          "type": "vec2",
          "name": "offset"
        }
      ],
      "description": [
        "`interpolateAtOffset` returns the value of the input varying _interpolant_ sampled at an offset from the center of the pixel specified by _offset_. The two floating-point components of _offset_ give the offset in pixels in the _x_ and _y_ directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec3",
      "name": "interpolateAtOffset",
      "parameters": [
        {
          "type": "vec3",
          "name": "interpolant"
        },
        {
          "type": "vec2",
          "name": "offset"
        }
      ],
      "description": [
        "`interpolateAtOffset` returns the value of the input varying _interpolant_ sampled at an offset from the center of the pixel specified by _offset_. The two floating-point components of _offset_ give the offset in pixels in the _x_ and _y_ directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "interpolateAtOffset",
      "parameters": [
        {
          "type": "vec4",
          "name": "interpolant"
        },
        {
          "type": "vec2",
          "name": "offset"
        }
      ],
      "description": [
        "`interpolateAtOffset` returns the value of the input varying _interpolant_ sampled at an offset from the center of the pixel specified by _offset_. The two floating-point components of _offset_ give the offset in pixels in the _x_ and _y_ directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "interpolateAtSample",
      "parameters": [
        {
          "type": "float",
          "name": "interpolant"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`interpolateAtSample` returns the value of the input varying _interpolant_ sampled at the location of sample number _sample_. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample _sample_ does not exist, the position used to interpolate the input varying is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "interpolateAtSample",
      "parameters": [
        {
          "type": "vec2",
          "name": "interpolant"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`interpolateAtSample` returns the value of the input varying _interpolant_ sampled at the location of sample number _sample_. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample _sample_ does not exist, the position used to interpolate the input varying is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec3",
      "name": "interpolateAtSample",
      "parameters": [
        {
          "type": "vec3",
          "name": "interpolant"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`interpolateAtSample` returns the value of the input varying _interpolant_ sampled at the location of sample number _sample_. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample _sample_ does not exist, the position used to interpolate the input varying is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "interpolateAtSample",
      "parameters": [
        {
          "type": "vec4",
          "name": "interpolant"
        },
        {
          "type": "int",
          "name": "sample"
        }
      ],
      "description": [
        "`interpolateAtSample` returns the value of the input varying _interpolant_ sampled at the location of sample number _sample_. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample _sample_ does not exist, the position used to interpolate the input varying is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2",
      "name": "inverse",
      "parameters": [
        {
          "type": "mat2",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3",
      "name": "inverse",
      "parameters": [
        {
          "type": "mat3",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4",
      "name": "inverse",
      "parameters": [
        {
          "type": "mat4",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2",
      "name": "inverse",
      "parameters": [
        {
          "type": "dmat2",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3",
      "name": "inverse",
      "parameters": [
        {
          "type": "dmat3",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4",
      "name": "inverse",
      "parameters": [
        {
          "type": "dmat4",
          "name": "m"
        }
      ],
      "description": [
        "`inverse` returns the inverse of the matrix _m_. The values in the returned matrix are undefined if _m_ is singular or poorly-conditioned (nearly singular)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "inversesqrt",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`inversesqrt` returns the inverse of the square root of _x_. i.e., the value `1 / sqrt(x)`. Results are undefined if `x ≤ 0`."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "inversesqrt",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`inversesqrt` returns the inverse of the square root of _x_. i.e., the value `1 / sqrt(x)`. Results are undefined if `x ≤ 0`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genBType",
      "name": "isinf",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "For each element element _i_ of the result, `isinf` returns `true` if _x_[_i_] is posititve or negative floating point infinity and false otherwise."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genBType",
      "name": "isinf",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "For each element element _i_ of the result, `isinf` returns `true` if _x_[_i_] is posititve or negative floating point infinity and false otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genBType",
      "name": "isnan",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "For each element element _i_ of the result, `isnan` returns `true` if _x_[_i_] is posititve or negative floating point NaN (Not a Number) and false otherwise."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genBType",
      "name": "isnan",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "For each element element _i_ of the result, `isnan` returns `true` if _x_[_i_] is posititve or negative floating point NaN (Not a Number) and false otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "ldexp",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "exp"
        }
      ],
      "description": [
        "`ldexp` builds a floating point number from _x_ and the corresponding integral exponent of two in _exp_, returning:",
        "` significand ⋅ 2**exponent `",
        "If this product is too large to be represented in the floating point type, the result is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "ldexp",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "exp"
        }
      ],
      "description": [
        "`ldexp` builds a floating point number from _x_ and the corresponding integral exponent of two in _exp_, returning:",
        "` significand ⋅ 2**exponent `",
        "If this product is too large to be represented in the floating point type, the result is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genFType",
      "name": "ldexp",
      "parameters": [
        {
          "type": "genFType",
          "name": "x"
        },
        {
          "modifiers": "in",
          "type": "genI32Type",
          "name": "exp"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "float",
      "name": "length",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`length` returns the length of the vector. i.e., ` sqrt( x [ 0 ] **2 + x [ 1 ] **2 + …) `"
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "double",
      "name": "length",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`length` returns the length of the vector. i.e., ` sqrt( x [ 0 ] **2 + x [ 1 ] **2 + …) `"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThan",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] < _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThan",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] < _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThan",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThan` returns a boolean vector in which each element _i_ is computed as _x_[_i_] < _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThanEqual",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≤ _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThanEqual",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≤ _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "lessThanEqual",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`lessThanEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] ≤ _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "log",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`log` returns the natural logarithm of _x_. i.e., the value `y` which satisfies `x = e**y`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "log2",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`log2` returns the base 2 logarithm of _x_. i.e., the value `y` which satisfies `x = 2**y`. Results are undefined if `x ≤ 0`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "main",
      "parameters": [],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "mat",
      "name": "matrixCompMult",
      "parameters": [
        {
          "type": "mat",
          "name": "x"
        },
        {
          "type": "mat",
          "name": "y"
        }
      ],
      "description": [
        "`matrixCompMult` performs a component-wise multiplication of two matrices, yielding a result matrix where each component, `result[i][j]` is computed as the scalar product of `_x_[i][j]` and `_y_[i][j]`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat",
      "name": "matrixCompMult",
      "parameters": [
        {
          "type": "dmat",
          "name": "x"
        },
        {
          "type": "dmat",
          "name": "y"
        }
      ],
      "description": [
        "`matrixCompMult` performs a component-wise multiplication of two matrices, yielding a result matrix where each component, `result[i][j]` is computed as the scalar product of `_x_[i][j]` and `_y_[i][j]`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "max",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "max",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "float",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "max",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "max",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "double",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "max",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "max",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "int",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "max",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "max",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "uint",
          "name": "y"
        }
      ],
      "description": [
        "`max` returns the maximum of the two parameters. It returns _y_ if _y_ is greater than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrier",
      "parameters": [],
      "description": [
        "`memoryBarrier` waits on the completion of all memory accesses resulting from the use of image variables or atomic counters and then returns with no other effect. When this function returns, the results of any memory stores performed using coherent variables performed prior to the call will be visible to any future coherent memory access to the same addresses from other shader invocations. In particular, the values written this way in one shader stage are guaranteed to be visible to coherent memory accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrier",
      "parameters": [
        {
          "type": "int",
          "name": "memory"
        },
        {
          "type": "int",
          "name": "storage"
        },
        {
          "type": "int",
          "name": "sem"
        }
      ],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierAtomicCounter",
      "parameters": [],
      "description": [
        "`memoryBarrierAtomicCounter` waits on the completion of all accesses resulting from the use of atomic counters and then returns with no other effect. When this function returns, the results of any modifications to the value of atomic counters will be visible to any access to the same counter from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation)."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierBuffer",
      "parameters": [],
      "description": [
        "`memoryBarrierBuffer` waits on the completion of all memory accesses resulting from the use of buffer variables and then returns with no other effect. When this function returns, the results of any modifications to the content of buffer variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation)."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierBuffer",
      "parameters": [],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierImage",
      "parameters": [],
      "description": [
        "`memoryBarrierImage` waits on the completion of all memory accesses resulting from the use of image variables and then returns with no other effect. When this function returns, the results of any modifications to the content of image variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation)."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierImage",
      "parameters": [],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierShared",
      "parameters": [],
      "description": [
        "`memoryBarrierShared` waits on the completion of all memory accesses resulting from the use of shared variables and then returns with no other effect. When this function returns, the results of any modifications to the content of shared variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).",
        "`memoryBarrierShared` is available only in the compute language."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierShared",
      "parameters": [],
      "extensions": [
        "GL_EXT_mesh_shader"
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierShared",
      "parameters": [],
      "extensions": [
        "GL_KHR_memory_scope_semantics"
      ]
    },
    {
      "return_type": "void",
      "name": "memoryBarrierShared",
      "parameters": [],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    },
    {
      "return_type": "genType",
      "name": "min",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "min",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "float",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "min",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "min",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "double",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "min",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "min",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "int",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "min",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "min",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "uint",
          "name": "y"
        }
      ],
      "description": [
        "`min` returns the minimum of the two parameters. It returns _y_ if _y_ is less than _x_, otherwise it returns _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "mix",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        },
        {
          "type": "genType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "mix",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        },
        {
          "type": "float",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "mix",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        },
        {
          "type": "genDType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "mix",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        },
        {
          "type": "double",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "mix",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        },
        {
          "type": "genBType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "mix",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        },
        {
          "type": "genBType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "mix",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        },
        {
          "type": "genIType",
          "name": "y"
        },
        {
          "type": "genBType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "mix",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        },
        {
          "type": "genBType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genBType",
      "name": "mix",
      "parameters": [
        {
          "type": "genBType",
          "name": "x"
        },
        {
          "type": "genBType",
          "name": "y"
        },
        {
          "type": "genBType",
          "name": "a"
        }
      ],
      "description": [
        "`mix` performs a linear interpolation between _x_ and _y_ using _a_ to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.",
        "The variants of `mix` where _a_ is `genBType` select which vector each returned component comes from. For a component of _a_ that is false, the corresponding component of _x_ is returned. For a component of _a_ that is true, the corresponding component of _y_ is returned. Components of _x_ and _y_ that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "mod",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "float",
          "name": "y"
        }
      ],
      "description": [
        "`mod` returns the value of _x_ modulo _y_. This is computed as _x_ - _y_ * floor(_x_/_y_)."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "mod",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        }
      ],
      "description": [
        "`mod` returns the value of _x_ modulo _y_. This is computed as _x_ - _y_ * floor(_x_/_y_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "mod",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "double",
          "name": "y"
        }
      ],
      "description": [
        "`mod` returns the value of _x_ modulo _y_. This is computed as _x_ - _y_ * floor(_x_/_y_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "mod",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "type": "genDType",
          "name": "y"
        }
      ],
      "description": [
        "`mod` returns the value of _x_ modulo _y_. This is computed as _x_ - _y_ * floor(_x_/_y_)."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "modf",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "modifiers": "out",
          "type": "genType",
          "name": "i"
        }
      ],
      "description": [
        "`modf` separates a floating point value _x_ into its integer and fractional parts. The fractional part of the number is returned from the function and the integer part (as a floating point quantity) is returned in the output parameter _i_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "modf",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        },
        {
          "modifiers": "out",
          "type": "genDType",
          "name": "i"
        }
      ],
      "description": [
        "`modf` separates a floating point value _x_ into its integer and fractional parts. The fractional part of the number is returned from the function and the integer part (as a floating point quantity) is returned in the output parameter _i_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "noise1",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value _x_. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:",
        "",
        "The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.",
        "The return value(s) have an overall average of 0.0.",
        "They are repeatable, in that a particular input value will always produce the same return value.",
        "They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).",
        "They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).",
        "They typically give different results under translation.",
        "The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.",
        "They are C1 continuous everywhere (i.e., the first derivative is continuous).",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "noise2",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value _x_. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:",
        "",
        "The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.",
        "The return value(s) have an overall average of 0.0.",
        "They are repeatable, in that a particular input value will always produce the same return value.",
        "They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).",
        "They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).",
        "They typically give different results under translation.",
        "The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.",
        "They are C1 continuous everywhere (i.e., the first derivative is continuous).",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec3",
      "name": "noise3",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value _x_. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:",
        "",
        "The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.",
        "The return value(s) have an overall average of 0.0.",
        "They are repeatable, in that a particular input value will always produce the same return value.",
        "They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).",
        "They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).",
        "They typically give different results under translation.",
        "The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.",
        "They are C1 continuous everywhere (i.e., the first derivative is continuous).",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "noise4",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value _x_. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:",
        "",
        "The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.",
        "The return value(s) have an overall average of 0.0.",
        "They are repeatable, in that a particular input value will always produce the same return value.",
        "They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).",
        "They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).",
        "They typically give different results under translation.",
        "The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.",
        "They are C1 continuous everywhere (i.e., the first derivative is continuous).",
        ""
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "normalize",
      "parameters": [
        {
          "type": "genType",
          "name": "v"
        }
      ],
      "description": [
        "`normalize` returns a vector with the same direction as its parameter, _v_, but with length 1."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "normalize",
      "parameters": [
        {
          "type": "genDType",
          "name": "v"
        }
      ],
      "description": [
        "`normalize` returns a vector with the same direction as its parameter, _v_, but with length 1."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "not",
      "parameters": [
        {
          "type": "bvec",
          "name": "x"
        }
      ],
      "description": [
        "`not` logically inverts the boolean vector _x_. It returns a new boolean vector for which each element _i_ is computed as `!_x_[_i_]`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "notEqual",
      "parameters": [
        {
          "type": "vec",
          "name": "x"
        },
        {
          "type": "vec",
          "name": "y"
        }
      ],
      "description": [
        "`notEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] != _y_[_i_]."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "notEqual",
      "parameters": [
        {
          "type": "ivec",
          "name": "x"
        },
        {
          "type": "ivec",
          "name": "y"
        }
      ],
      "description": [
        "`notEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] != _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "bvec",
      "name": "notEqual",
      "parameters": [
        {
          "type": "uvec",
          "name": "x"
        },
        {
          "type": "uvec",
          "name": "y"
        }
      ],
      "description": [
        "`notEqual` returns a boolean vector in which each element _i_ is computed as _x_[_i_] != _y_[_i_]."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec2",
          "name": "c"
        },
        {
          "type": "vec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec3",
          "name": "c"
        },
        {
          "type": "vec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec4",
          "name": "c"
        },
        {
          "type": "vec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2x3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec3",
          "name": "c"
        },
        {
          "type": "vec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3x2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec2",
          "name": "c"
        },
        {
          "type": "vec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2x4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec4",
          "name": "c"
        },
        {
          "type": "vec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4x2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec2",
          "name": "c"
        },
        {
          "type": "vec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3x4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec4",
          "name": "c"
        },
        {
          "type": "vec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "vec3",
          "name": "c"
        },
        {
          "type": "vec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec2",
          "name": "c"
        },
        {
          "type": "dvec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec3",
          "name": "c"
        },
        {
          "type": "dvec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec4",
          "name": "c"
        },
        {
          "type": "dvec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2x3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec3",
          "name": "c"
        },
        {
          "type": "dvec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3x2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec2",
          "name": "c"
        },
        {
          "type": "dvec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2x4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec4",
          "name": "c"
        },
        {
          "type": "dvec2",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4x2",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec2",
          "name": "c"
        },
        {
          "type": "dvec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3x4",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec4",
          "name": "c"
        },
        {
          "type": "dvec3",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4x3",
      "name": "outerProduct",
      "parameters": [
        {
          "type": "dvec3",
          "name": "c"
        },
        {
          "type": "dvec4",
          "name": "r"
        }
      ],
      "description": [
        "`outerProduct` treats the first parameter _c_ as a column vector (matrix with one column) and the second parameter _r_ as a row vector (matrix with one row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a matrix whose number of rows is the number of components in _c_ and whose number of columns is the number of components in _r_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int16_t",
      "name": "pack16",
      "parameters": [
        {
          "type": "i8vec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "int32_t",
      "name": "pack32",
      "parameters": [
        {
          "type": "i16vec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "int64_t",
      "name": "pack64",
      "parameters": [
        {
          "type": "i32vec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "double",
      "name": "packDouble2x32",
      "parameters": [
        {
          "type": "uvec2",
          "name": "v"
        }
      ],
      "description": [
        "`packDouble2x32` packs the component of parameter _v_ into a 64-bit value. If an IEEE-754 infinity or NaN is created, it will not signal and the resulting floating-point value is undefined. Otherwise, the bit-level representation of _v_ is preserved. The first vector component (`v[0]`) specifies the 32 least significant bits of the result; the second component (`v[1]`) specifies the 32 most significant bits."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint32_t",
      "name": "packFloat2x16",
      "parameters": [
        {
          "type": "f16vec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uint",
      "name": "packHalf2x16",
      "parameters": [
        {
          "type": "vec2",
          "name": "v"
        }
      ],
      "description": [
        "`packHalf2x16` returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int64_t",
      "name": "packInt2x32",
      "parameters": [
        {
          "type": "ivec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uint",
      "name": "packSnorm2x16",
      "parameters": [
        {
          "type": "vec2",
          "name": "v"
        }
      ],
      "description": [
        "`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value _v_ into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.",
        "The conversion for component _c_ of _v_ to fixed-point is performed as follows:",
        "`packUnorm2x16`: `round(clamp(_c_, 0.0, 1.0) * 65535.0)`",
        "`packSnorm2x16`: `round(clamp(_c_, -1.0, 1.0) * 32767.0)`",
        "`packUnorm4x8`: `round(clamp(_c_, 0.0, 1.0) * 255.0)`",
        "`packSnorm4x8`: `round(clamp(_c_, -1.0, 1.0) * 127.0)`",
        "",
        "The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "packSnorm4x8",
      "parameters": [
        {
          "type": "vec4",
          "name": "v"
        }
      ],
      "description": [
        "`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value _v_ into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.",
        "The conversion for component _c_ of _v_ to fixed-point is performed as follows:",
        "`packUnorm2x16`: `round(clamp(_c_, 0.0, 1.0) * 65535.0)`",
        "`packSnorm2x16`: `round(clamp(_c_, -1.0, 1.0) * 32767.0)`",
        "`packUnorm4x8`: `round(clamp(_c_, 0.0, 1.0) * 255.0)`",
        "`packSnorm4x8`: `round(clamp(_c_, -1.0, 1.0) * 127.0)`",
        "",
        "The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint32_t",
      "name": "packUint2x16",
      "parameters": [
        {
          "type": "u16vec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "packUint2x32",
      "parameters": [
        {
          "type": "uvec2",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uint64_t",
      "name": "packUint4x16",
      "parameters": [
        {
          "type": "u16vec4",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uint",
      "name": "packUnorm2x16",
      "parameters": [
        {
          "type": "vec2",
          "name": "v"
        }
      ],
      "description": [
        "`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value _v_ into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.",
        "The conversion for component _c_ of _v_ to fixed-point is performed as follows:",
        "`packUnorm2x16`: `round(clamp(_c_, 0.0, 1.0) * 65535.0)`",
        "`packSnorm2x16`: `round(clamp(_c_, -1.0, 1.0) * 32767.0)`",
        "`packUnorm4x8`: `round(clamp(_c_, 0.0, 1.0) * 255.0)`",
        "`packSnorm4x8`: `round(clamp(_c_, -1.0, 1.0) * 127.0)`",
        "",
        "The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "uint",
      "name": "packUnorm4x8",
      "parameters": [
        {
          "type": "vec4",
          "name": "v"
        }
      ],
      "description": [
        "`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value _v_ into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.",
        "The conversion for component _c_ of _v_ to fixed-point is performed as follows:",
        "`packUnorm2x16`: `round(clamp(_c_, 0.0, 1.0) * 65535.0)`",
        "`packSnorm2x16`: `round(clamp(_c_, -1.0, 1.0) * 32767.0)`",
        "`packUnorm4x8`: `round(clamp(_c_, 0.0, 1.0) * 255.0)`",
        "`packSnorm4x8`: `round(clamp(_c_, -1.0, 1.0) * 127.0)`",
        "",
        "The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "pow",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        },
        {
          "type": "genType",
          "name": "y"
        }
      ],
      "description": [
        "`pow` returns the value of _x_ raised to the _y_ power. i.e., `x**y`. Results are undefined if `x <` or if `x = 0` and `y = 0`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "radians",
      "parameters": [
        {
          "type": "genType",
          "name": "degrees"
        }
      ],
      "description": [
        "`radians` converts a quantity, specified in degrees into radians. That is, the return value is ` π ⋅ degrees / 180 `."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "rayQueryConfirmIntersectionEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "void",
      "name": "rayQueryGenerateIntersectionEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "float",
          "name": "tHit"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "vec2",
      "name": "rayQueryGetIntersectionBarycentricsEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "bool",
      "name": "rayQueryGetIntersectionCandidateAABBOpaqueEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "bool",
      "name": "rayQueryGetIntersectionFrontFaceEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "int",
      "name": "rayQueryGetIntersectionGeometryIndexEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "int",
      "name": "rayQueryGetIntersectionInstanceCustomIndexEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "int",
      "name": "rayQueryGetIntersectionInstanceIdEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "uint",
      "name": "rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "vec3",
      "name": "rayQueryGetIntersectionObjectRayDirectionEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "vec3",
      "name": "rayQueryGetIntersectionObjectRayOriginEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "rayQueryGetIntersectionObjectToWorldEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "int",
      "name": "rayQueryGetIntersectionPrimitiveIndexEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "float",
      "name": "rayQueryGetIntersectionTEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "void",
      "name": "rayQueryGetIntersectionTriangleVertexPositionsEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        },
        {
          "modifiers": "out",
          "type": "vec3[3]",
          "name": "positions"
        }
      ],
      "extensions": [
        "GL_EXT_ray_tracing_position_fetch"
      ]
    },
    {
      "return_type": "uint",
      "name": "rayQueryGetIntersectionTypeEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "rayQueryGetIntersectionWorldToObjectEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        },
        {
          "type": "bool",
          "name": "committed"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "uint",
      "name": "rayQueryGetRayFlagsEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "float",
      "name": "rayQueryGetRayTMinEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "vec3",
      "name": "rayQueryGetWorldRayDirectionEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "vec3",
      "name": "rayQueryGetWorldRayOriginEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "void",
      "name": "rayQueryInitializeEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "rayQuery"
        },
        {
          "type": "accelerationStructureEXT",
          "name": "topLevel"
        },
        {
          "type": "uint",
          "name": "rayFlags"
        },
        {
          "type": "uint",
          "name": "cullMask"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "tMin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "tMax"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "bool",
      "name": "rayQueryProceedEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "void",
      "name": "rayQueryTerminateEXT",
      "parameters": [
        {
          "type": "rayQueryEXT",
          "name": "q"
        }
      ],
      "extensions": [
        "GL_EXT_ray_query"
      ]
    },
    {
      "return_type": "genType",
      "name": "reflect",
      "parameters": [
        {
          "type": "genType",
          "name": "I"
        },
        {
          "type": "genType",
          "name": "N"
        }
      ],
      "description": [
        "For a given incident vector _I_ and surface normal _N_ `reflect` returns the reflection direction calculated as `_I_ - 2.0 * dot(_N_, _I_) * _N_`.",
        "_N_ should be normalized in order to achieve the desired result."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "reflect",
      "parameters": [
        {
          "type": "genDType",
          "name": "I"
        },
        {
          "type": "genDType",
          "name": "N"
        }
      ],
      "description": [
        "For a given incident vector _I_ and surface normal _N_ `reflect` returns the reflection direction calculated as `_I_ - 2.0 * dot(_N_, _I_) * _N_`.",
        "_N_ should be normalized in order to achieve the desired result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "refract",
      "parameters": [
        {
          "type": "genType",
          "name": "I"
        },
        {
          "type": "genType",
          "name": "N"
        },
        {
          "type": "float",
          "name": "eta"
        }
      ],
      "description": [
        "For a given incident vector _I_, surface normal _N_ and ratio of indices of refraction, _eta_, `refract` returns the refraction vector, _R_.",
        "_R_ is calculated as:",
        "",
        "",
        "The input parameters _I_ and _N_ should be normalized in order to achieve the desired result."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "refract",
      "parameters": [
        {
          "type": "genDType",
          "name": "I"
        },
        {
          "type": "genDType",
          "name": "N"
        },
        {
          "type": "float",
          "name": "eta"
        }
      ],
      "description": [
        "For a given incident vector _I_, surface normal _N_ and ratio of indices of refraction, _eta_, `refract` returns the refraction vector, _R_.",
        "_R_ is calculated as:",
        "",
        "",
        "The input parameters _I_ and _N_ should be normalized in order to achieve the desired result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "reorderThreadNV",
      "parameters": [
        {
          "type": "uint",
          "name": "hint"
        },
        {
          "type": "uint",
          "name": "bits"
        }
      ],
      "extensions": [
        "GL_NV_shader_invocation_reorder"
      ]
    },
    {
      "return_type": "bool",
      "name": "reportIntersectionEXT",
      "parameters": [
        {
          "type": "float",
          "name": "hitT"
        },
        {
          "type": "uint",
          "name": "hitKind"
        }
      ],
      "extensions": [
        "GL_EXT_ray_tracing"
      ]
    },
    {
      "return_type": "bool",
      "name": "reportIntersectionNV",
      "parameters": [
        {
          "type": "float",
          "name": "hitT"
        },
        {
          "type": "uint",
          "name": "hitKind"
        }
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "genType",
      "name": "round",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`round` returns a value equal to the nearest integer to _x_. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that `round`(_x_) returns the same value as roundEven(_x_) for all values of _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "round",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`round` returns a value equal to the nearest integer to _x_. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that `round`(_x_) returns the same value as roundEven(_x_) for all values of _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "roundEven",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`roundEven` returns a value equal to the nearest integer to _x_. The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "roundEven",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`roundEven` returns a value equal to the nearest integer to _x_. The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "sign",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`sign` returns -1.0 if _x_ is less than 0.0, 0.0 if _x_ is equal to 0.0, and +1.0 if _x_ is greater than 0.0."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genIType",
      "name": "sign",
      "parameters": [
        {
          "type": "genIType",
          "name": "x"
        }
      ],
      "description": [
        "`sign` returns -1.0 if _x_ is less than 0.0, 0.0 if _x_ is equal to 0.0, and +1.0 if _x_ is greater than 0.0."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "sign",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`sign` returns -1.0 if _x_ is less than 0.0, 0.0 if _x_ is equal to 0.0, and +1.0 if _x_ is greater than 0.0."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "sin",
      "parameters": [
        {
          "type": "genType",
          "name": "angle"
        }
      ],
      "description": [
        "`sin` returns the trigonometric sine of _angle_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "sinh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`sinh` returns the hyperbolic sine of `x`. The hyperbolic sine of `x` is computed as ` e**x − e** − x / 2 `."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "smoothstep",
      "parameters": [
        {
          "type": "genType",
          "name": "edge0"
        },
        {
          "type": "genType",
          "name": "edge1"
        },
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`smoothstep` performs smooth Hermite interpolation between 0 and 1 when _edge0_ < _x_ < _edge1_. This is useful in cases where a threshold function with a smooth transition is desired. `smoothstep` is equivalent to:",
        "",
        "",
        "Results are undefined if _edge0_ ≥ _edge1_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "smoothstep",
      "parameters": [
        {
          "type": "float",
          "name": "edge0"
        },
        {
          "type": "float",
          "name": "edge1"
        },
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`smoothstep` performs smooth Hermite interpolation between 0 and 1 when _edge0_ < _x_ < _edge1_. This is useful in cases where a threshold function with a smooth transition is desired. `smoothstep` is equivalent to:",
        "",
        "",
        "Results are undefined if _edge0_ ≥ _edge1_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "smoothstep",
      "parameters": [
        {
          "type": "genDType",
          "name": "edge0"
        },
        {
          "type": "genDType",
          "name": "edge1"
        },
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`smoothstep` performs smooth Hermite interpolation between 0 and 1 when _edge0_ < _x_ < _edge1_. This is useful in cases where a threshold function with a smooth transition is desired. `smoothstep` is equivalent to:",
        "",
        "",
        "Results are undefined if _edge0_ ≥ _edge1_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "smoothstep",
      "parameters": [
        {
          "type": "double",
          "name": "edge0"
        },
        {
          "type": "double",
          "name": "edge1"
        },
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`smoothstep` performs smooth Hermite interpolation between 0 and 1 when _edge0_ < _x_ < _edge1_. This is useful in cases where a threshold function with a smooth transition is desired. `smoothstep` is equivalent to:",
        "",
        "",
        "Results are undefined if _edge0_ ≥ _edge1_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "sqrt",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`sqrt` returns the square root of _x_. i.e., the value `sqrt(x)`. Results are undefined if `x < 0`."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "sqrt",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`sqrt` returns the square root of _x_. i.e., the value `sqrt(x)`. Results are undefined if `x < 0`."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "step",
      "parameters": [
        {
          "type": "genType",
          "name": "edge"
        },
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`step` generates a step function by comparing _x_ to _edge_.",
        "For element _i_ of the return value, 0.0 is returned if _x_[_i_] < _edge_[_i_], and 1.0 is returned otherwise."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "step",
      "parameters": [
        {
          "type": "float",
          "name": "edge"
        },
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`step` generates a step function by comparing _x_ to _edge_.",
        "For element _i_ of the return value, 0.0 is returned if _x_[_i_] < _edge_[_i_], and 1.0 is returned otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "step",
      "parameters": [
        {
          "type": "genDType",
          "name": "edge"
        },
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`step` generates a step function by comparing _x_ to _edge_.",
        "For element _i_ of the return value, 0.0 is returned if _x_[_i_] < _edge_[_i_], and 1.0 is returned otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "step",
      "parameters": [
        {
          "type": "double",
          "name": "edge"
        },
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`step` generates a step function by comparing _x_ to _edge_.",
        "For element _i_ of the return value, 0.0 is returned if _x_[_i_] < _edge_[_i_], and 1.0 is returned otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupAdd",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupAdd()` returns the summation of all active invocation\nprovided `value`s.  The method that is used to perform the operation on\neach active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupAll",
      "parameters": [
        {
          "type": "bool",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_vote` is enabled.",
        "The function `subgroupAll()` returns true if for all active invocations\n`value` evaluates to true."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_vote"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupAllEqual",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_vote` is enabled.",
        "The function `subgroupAllEqual()` returns true if `value` for all active\ninvocations is equal across the subgroup."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_vote"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupAnd",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupAnd()` returns the bitwise\nAND of all active invocation provided `value`s.  For genBType, the function\n`subgroupAnd()` returns the logical AND of all active invocation provided\n`value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupAny",
      "parameters": [
        {
          "type": "bool",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_vote` is enabled.",
        "The function `subgroupAny()` returns true if for any active invocation its\n`value` evaluates to true."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_vote"
      ]
    },
    {
      "return_type": "uvec4",
      "name": "subgroupBallot",
      "parameters": [
        {
          "type": "bool",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallot()` returns a set of bitfields containing the\nresult of evaluating the expression `value` in all active invocations in the\nsubgroup.  If `value` evaluates to true for an active invocation then the\nbit corresponding to the `gl_SubgroupInvocationID` for the invocation is\nset to one in the result, otherwise the bit is set to zero.  Bits\ncorresponding to inactive invocations are set to zero.  The following\nassumptions can be made:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "uint",
      "name": "subgroupBallotBitCount",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotBitCount()` returns the number of bits that are\nset to 1 in the bits used to hold the subgroup invocations of `value`.\nThe bits are counted across the components of `value`.  This is useful in\nconjunction with `subgroupBallot()` to get the number of active invocations\nthat contributed a true value."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupBallotBitExtract",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "index"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotBitExtract()` returns a bool that is true if the\nbit in `value` that corresponds to `index` (where `index` begins at bit 0 of\nthe first vector component) is 1, and false otherwise.  If `index` is\ngreater than or equal to `gl_SubgroupSize`, an undefined result is returned.\nThis is useful in conjunction with `subgroupBallot()`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "uint",
      "name": "subgroupBallotExclusiveBitCount",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotExclusiveBitCount()` returns the number of bits\nthat are set to 1 in the ballot value for subgroup invocations with a lower\n`gl_SubgroupInvocationID`.  The bits are exclusively counted across the\ncomponents of `value`.  This is useful in conjunction with `subgroupBallot()`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "uint",
      "name": "subgroupBallotFindLSB",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotFindLSB()` returns the bit number of the least\nsignificant bit set to 1 in the bits used to hold the subgroup invocations\nof `value`.  If `value` is 0, an undefined value is returned.  This is\nuseful in conjunction with `subgroupBallot()`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "uint",
      "name": "subgroupBallotFindMSB",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotFindMSB()` returns the bit number of the most\nsignificant bit set to 1 in the bits used to hold the subgroup invocations\nof `value`.  If `value` is 0, an undefined value is returned.  This is\nuseful in conjunction with `subgroupBallot()`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "uint",
      "name": "subgroupBallotInclusiveBitCount",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBallotInclusiveBitCount()` returns the number of bits\nthat are set to 1 in the ballot value for subgroup invocations with a lower,\nor equal to, `gl_SubgroupInvocationID`.  The bits are inclusively counted\nacross the components of `value`.  This is useful in conjunction with\n`subgroupBallot()`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "void",
      "name": "subgroupBarrier",
      "parameters": [],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_basic` is enabled.",
        "The function `subgroupBarrier()` enforces that all active invocations within a\nsubgroup must execute this function before any are allowed to continue their\nexecution, and the results of any memory stores performed using coherent\nvariables performed prior to the call will be visible to any future\ncoherent access to the same memory performed by any other shader invocation\nwithin the same subgroup."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupBroadcast",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "id"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBroadcast()` returns the `value` from the invocation\nwhose `gl_SubgroupInvocationID` is equal to `id`. `id` must be an integral\nconstant expression when targeting SPIR-V 1.4 and below, otherwise it must\nbe dynamically uniform within the subgroup.  If the `id` is an inactive\ninvocation or is greater than or equal to `gl_SubgroupSize`, an undefined\nvalue is returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupBroadcastFirst",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupBroadcastFirst()` returns the `value` from the active\ninvocation with the lowest `gl_SubgroupInvocationID`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupClusteredAdd",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "The function `subgroupClusteredAdd()` returns a clustered operation that is\nthe summation of all active invocation-provided `value`s within a cluster,\nwith a cluster size of `clusterSize`.  The method used to perform the\noperation on each active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupClusteredAnd",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "For genIType and genUType, the function `subgroupClusteredAnd()` returns a\nclustered operation that is the bitwise AND of all active\ninvocation-provided `value`s within a cluster.  For genBType, the function\n`subgroupClusteredAnd()` returns a clustered operation that is the logical\nAND of all active invocation-provided `value`s within a cluster."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupClusteredMax",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "The function `subgroupClusteredMax()` returns a clustered operation that is\nthe maximum of all active invocation-provided `value`s within a\ncluster, with a cluster size of `clusterSize`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupClusteredMin",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "The function `subgroupClusteredMin()` returns a clustered operation that is\nthe minimum of all active invocation-provided `value`s within a\ncluster, with a cluster size of `clusterSize`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupClusteredMul",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "The function `subgroupClusteredMul()` returns a clustered operation that is\nthe multiplication of all active invocation-provided `value`s within a\ncluster, with a cluster size of `clusterSize`.  The method used to perform\nthe operation on each active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupClusteredOr",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "For genIType and genUType, the function `subgroupClusteredOr()` returns a\nclustered operation that is the bitwise OR of all active\ninvocation-provided `value`s within a cluster.  For genBType, the function\n`subgroupClusteredOr()` returns a clustered operation that is the logical\ninclusive OR of all active invocation-provided `value`s within a cluster."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupClusteredXor",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "clusterSize"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_clustered` is enabled.",
        "For genIType and genUType, the function `subgroupClusteredXor()` returns a\nclustered operation that is the bitwise XOR of all active\ninvocation-provided `value`s within a cluster.  For genBType, the function\n`subgroupClusteredXor()` returns a clustered operation that is the logical\nexclusive OR of all active invocation-provided `value`s within a cluster."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_clustered"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupElect",
      "parameters": [],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_basic` is enabled.",
        "The function `subgroupElect()` returns true for exactly one invocation out of\nthe set of active invocations that execute a dynamic instance of this\ninstruction.  All other active invocations will return false.  The\ninvocation chosen is the active invocation with the lowest\n`gl_SubgroupInvocationID`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupExclusiveAdd",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupExclusiveAdd()` returns an exclusive scan operation\nthat is the summation of all active invocation-provided `value`s.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupExclusiveAnd",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupExclusiveAnd()` returns an\nexclusive scan operation that is the bitwise AND of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupExclusiveAnd()` returns an exclusive scan operation that is the\nlogical AND of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupExclusiveMax",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupExclusiveMax()` returns an exclusive scan operation\nthat is the maximum `value` of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupExclusiveMin",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupExclusiveMin()` returns an exclusive scan operation\nthat is the minimum `value` of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupExclusiveMul",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupExclusiveMul()` returns an exclusive scan operation\nthat is the multiplication of all active invocation-provided `value`s.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupExclusiveOr",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupExclusiveOr()` returns an\nexclusive scan operation that is the bitwise OR of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupExclusiveOr()` returns an exclusive scan operation that is the\nlogical inclusive OR of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupExclusiveXor",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupExclusiveXor()` returns an\nexclusive scan operation that is the bitwise XOR of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupExclusiveXor()` returns an exclusive scan operation that is the\nlogical exclusive OR of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupInclusiveAdd",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupInclusiveAdd()` returns an inclusive scan operation\nthat is the summation of all active invocation-provided `value`s.  The\nmethod used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupInclusiveAnd",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupInclusiveAnd()` returns an\ninclusive scan operation that is the bitwise AND of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupInclusiveAnd()` returns an inclusive scan operation that is the\nlogical AND of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupInclusiveMax",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupInclusiveMax()` returns an inclusive scan operation\nthat is the maximum `value` of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupInclusiveMin",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupInclusiveMin()` returns an inclusive scan operation\nthat is the minimum `value` of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupInclusiveMul",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupInclusiveMul()` returns an inclusive scan operation\nthat is the multiplication of all active invocation-provided `value`s.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupInclusiveOr",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupInclusiveOr()` returns an\ninclusive scan operation that is the bitwise OR of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupInclusiveOr()` returns an inclusive scan operation that is the\nlogical inclusive OR of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupInclusiveXor",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupInclusiveXor()` returns an\ninclusive scan operation that is the bitwise XOR of all active\ninvocation-provided `value`s.  For genBType, the function\n`subgroupInclusiveXor()` returns an inclusive scan operation that is the\nlogical exclusive OR of all active invocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "bool",
      "name": "subgroupInverseBallot",
      "parameters": [
        {
          "type": "uvec4",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_ballot` is enabled.",
        "The function `subgroupInverseBallot()` returns a bool that is true if the bit\nin `value` that corresponds to the current invocation's\n`gl_SubgroupInvocationID` in `value` is true.  All active invocations must\ncall `subgroupInverseBallot()` with the same `value`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_ballot"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupMax",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupMax()` returns the maximum `value` of all active\ninvocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "void",
      "name": "subgroupMemoryBarrier",
      "parameters": [],
      "description": [
        "Helper invocations participate in subgroup operations but, for operations\nother than subgroupQuad operations, they may be treated as inactive even\nif they would be considered otherwise active.",
        "For each active invocation within a subgroup that reaches the same\ndynamic instance of a subgroup built-in function, all active invocations\nwithin a subgroup must execute the dynamic instance of the function\nbefore any invocation can proceed.",
        "The subgroup memory barrier built-in functions can be used to order\nreads and writes to variables stored in memory accessible to other\nshader invocations within a subgroup.  When called, these functions will\nwait for the completion of all reads and writes previously performed by\nthe caller that access selected variable types, and then return with no\nother effect.  The built-in functions `subgroupMemoryBarrierBuffer()`,\n`subgroupMemoryBarrierShared()`, and `subgroupMemoryBarrierImage()` wait for\nthe completion of accesses to buffer, shared, and image variables,\nrespectively.  The built-in functions `subgroupBarrier()` and\n`subgroupMemoryBarrier()` wait for the completion of accesses to all of\nthe above variable types.  The function `subgroupMemoryBarrierShared()` is\navailable only in compute shaders; the other functions are available in\nall shader types.",
        "When the subgroup memory barrier built-in functions return, the results\nof any memory stores performed using coherent variables performed prior\nto the call will be visible to any future coherent access to the same\nmemory performed by any other shader invocation within the same\nsubgroup.",
        "There are two classes of subgroup built-in functions that have common\nproperties - subgroupInclusive`op`() and subgroupExclusive`op`() where\n`op` is one of: Add, Mul, Min, Max, And, Or, Xor.",
        "These operations perform a scan operation across the active invocations\nwithin a subgroup in linear order starting at the active invocation\nwith the lowest `gl_SubgroupInvocationID`, increasing to the active\ninvocation with the highest `gl_SubgroupInvocationID`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "void",
      "name": "subgroupMemoryBarrierBuffer",
      "parameters": [],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_basic` is enabled.",
        "The function `subgroupMemoryBarrierBuffer()` enforces the ordering of all\nmemory transactions to buffer variables issued within a single shader\ninvocation, as viewed by other invocations in the same subgroup."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic"
      ]
    },
    {
      "return_type": "void",
      "name": "subgroupMemoryBarrierImage",
      "parameters": [],
      "description": [
        "Helper invocations participate in subgroup operations but, for operations\nother than subgroupQuad operations, they may be treated as inactive even\nif they would be considered otherwise active.",
        "For each active invocation within a subgroup that reaches the same\ndynamic instance of a subgroup built-in function, all active invocations\nwithin a subgroup must execute the dynamic instance of the function\nbefore any invocation can proceed.",
        "The subgroup memory barrier built-in functions can be used to order\nreads and writes to variables stored in memory accessible to other\nshader invocations within a subgroup.  When called, these functions will\nwait for the completion of all reads and writes previously performed by\nthe caller that access selected variable types, and then return with no\nother effect.  The built-in functions `subgroupMemoryBarrierBuffer()`,\n`subgroupMemoryBarrierShared()`, and `subgroupMemoryBarrierImage()` wait for\nthe completion of accesses to buffer, shared, and image variables,\nrespectively.  The built-in functions `subgroupBarrier()` and\n`subgroupMemoryBarrier()` wait for the completion of accesses to all of\nthe above variable types.  The function `subgroupMemoryBarrierShared()` is\navailable only in compute shaders; the other functions are available in\nall shader types.",
        "When the subgroup memory barrier built-in functions return, the results\nof any memory stores performed using coherent variables performed prior\nto the call will be visible to any future coherent access to the same\nmemory performed by any other shader invocation within the same\nsubgroup.",
        "There are two classes of subgroup built-in functions that have common\nproperties - subgroupInclusive`op`() and subgroupExclusive`op`() where\n`op` is one of: Add, Mul, Min, Max, And, Or, Xor.",
        "These operations perform a scan operation across the active invocations\nwithin a subgroup in linear order starting at the active invocation\nwith the lowest `gl_SubgroupInvocationID`, increasing to the active\ninvocation with the highest `gl_SubgroupInvocationID`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "void",
      "name": "subgroupMemoryBarrierShared",
      "parameters": [],
      "description": [
        "Helper invocations participate in subgroup operations but, for operations\nother than subgroupQuad operations, they may be treated as inactive even\nif they would be considered otherwise active.",
        "For each active invocation within a subgroup that reaches the same\ndynamic instance of a subgroup built-in function, all active invocations\nwithin a subgroup must execute the dynamic instance of the function\nbefore any invocation can proceed.",
        "The subgroup memory barrier built-in functions can be used to order\nreads and writes to variables stored in memory accessible to other\nshader invocations within a subgroup.  When called, these functions will\nwait for the completion of all reads and writes previously performed by\nthe caller that access selected variable types, and then return with no\nother effect.  The built-in functions `subgroupMemoryBarrierBuffer()`,\n`subgroupMemoryBarrierShared()`, and `subgroupMemoryBarrierImage()` wait for\nthe completion of accesses to buffer, shared, and image variables,\nrespectively.  The built-in functions `subgroupBarrier()` and\n`subgroupMemoryBarrier()` wait for the completion of accesses to all of\nthe above variable types.  The function `subgroupMemoryBarrierShared()` is\navailable only in compute shaders; the other functions are available in\nall shader types.",
        "When the subgroup memory barrier built-in functions return, the results\nof any memory stores performed using coherent variables performed prior\nto the call will be visible to any future coherent access to the same\nmemory performed by any other shader invocation within the same\nsubgroup.",
        "There are two classes of subgroup built-in functions that have common\nproperties - subgroupInclusive`op`() and subgroupExclusive`op`() where\n`op` is one of: Add, Mul, Min, Max, And, Or, Xor.",
        "These operations perform a scan operation across the active invocations\nwithin a subgroup in linear order starting at the active invocation\nwith the lowest `gl_SubgroupInvocationID`, increasing to the active\ninvocation with the highest `gl_SubgroupInvocationID`."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupMin",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupMin()` returns the minimum `value` of all active\ninvocation-provided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupMul",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "The function `subgroupMul()` returns the multiplication of all active\ninvocation-provided `value`s.  The method that is used to perform the\noperation on each active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupOr",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupOr()` returns the bitwise\nOR of all active invocation provided `value`s.  For genBType, the function\n`subgroupOr()` returns the logical inclusive OR of all active invocation\nprovided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "uvec4",
      "name": "subgroupPartitionNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionNV()` returns a ballot that is a valid\npartition of the active invocations such that all invocations in each\nsubset of the partition have the same value of `value`. For any two\ninvocations in different subsets of the partition, either their values of\n`value` must not be equal or one must be a floating point NaN."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedAddNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedAddNV()` returns the summation of all active invocation\nprovided `value`s in the invocation's subset of the partition.  The method that is used to perform the operation on\neach active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedAndNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedAndNV()` returns the bitwise\nAND of all active invocation provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedAndNV()` returns the logical AND of all active invocation provided\n`value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedExclusiveAddNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedExclusiveAddNV()` returns an exclusive scan operation\nthat is the summation of all active invocation-provided `value`s in the invocation's subset of the partition.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedExclusiveAndNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedExclusiveAndNV()` returns an\nexclusive scan operation that is the bitwise AND of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedExclusiveAndNV()` returns an exclusive scan operation that is the\nlogical AND of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedExclusiveMaxNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedExclusiveMaxNV()` returns an exclusive scan operation\nthat is the maximum `value` of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedExclusiveMinNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedExclusiveMinNV()` returns an exclusive scan operation\nthat is the minimum `value` of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedExclusiveMulNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedExclusiveMulNV()` returns an exclusive scan operation\nthat is the multiplication of all active invocation-provided `value`s in the invocation's subset of the partition.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedExclusiveOrNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedExclusiveOrNV()` returns an\nexclusive scan operation that is the bitwise OR of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedExclusiveOrNV()` returns an exclusive scan operation that is the\nlogical inclusive OR of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedExclusiveXorNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedExclusiveXorNV()` returns an\nexclusive scan operation that is the bitwise XOR of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedExclusiveXorNV()` returns an exclusive scan operation that is the\nlogical exclusive OR of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedInclusiveAddNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedInclusiveAddNV()` returns an inclusive scan operation\nthat is the summation of all active invocation-provided `value`s in the invocation's subset of the partition.  The\nmethod used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedInclusiveAndNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedInclusiveAndNV()` returns an\ninclusive scan operation that is the bitwise AND of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedInclusiveAndNV()` returns an inclusive scan operation that is the\nlogical AND of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedInclusiveMaxNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedInclusiveMaxNV()` returns an inclusive scan operation\nthat is the maximum `value` of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedInclusiveMinNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedInclusiveMinNV()` returns an inclusive scan operation\nthat is the minimum `value` of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedInclusiveMulNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedInclusiveMulNV()` returns an inclusive scan operation\nthat is the multiplication of all active invocation-provided `value`s in the invocation's subset of the partition.\nThe method used to perform the operation on each active invocation's `value`\nis implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedInclusiveOrNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedInclusiveOrNV()` returns an\ninclusive scan operation that is the bitwise OR of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedInclusiveOrNV()` returns an inclusive scan operation that is the\nlogical inclusive OR of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedInclusiveXorNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedInclusiveXorNV()` returns an\ninclusive scan operation that is the bitwise XOR of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedInclusiveXorNV()` returns an inclusive scan operation that is the\nlogical exclusive OR of all active invocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedMaxNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedMaxNV()` returns the maximum `value` of all active\ninvocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedMinNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedMinNV()` returns the minimum `value` of all active\ninvocation-provided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupPartitionedMulNV",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "The function `subgroupPartitionedMulNV()` returns the multiplication of all active\ninvocation-provided `value`s in the invocation's subset of the partition.  The method that is used to perform the\noperation on each active invocation's `value` is implementation defined."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedOrNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedOrNV()` returns the bitwise\nOR of all active invocation provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedOrNV()` returns the logical inclusive OR of all active invocation\nprovided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupPartitionedXorNV",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        },
        {
          "type": "uvec4",
          "name": "ballot"
        }
      ],
      "description": [
        "Only usable if the extension `GL_NV_shader_subgroup_partitioned` is enabled.",
        "For genIType and genUType, the function `subgroupPartitionedXorNV()` returns the bitwise\nXOR of all active invocation provided `value`s in the invocation's subset of the partition.  For genBType, the function\n`subgroupPartitionedXorNV()` returns the logical exclusive OR of all active invocation\nprovided `value`s in the invocation's subset of the partition."
      ],
      "extensions": [
        "GL_NV_shader_subgroup_partitioned"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupQuadBroadcast",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "id"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_quad` is enabled.",
        "The function `subgroupQuadBroadcast()` returns the `value` from the invocation\nwithin the quad whose `gl_SubgroupInvocationID` % 4 is equal to `id`.  `id`\nmust be an integral constant expression when targeting SPIR-V 1.4 and\nbelow, otherwise it must be dynamically uniform within the quad.  If the `id`\nis an inactive invocation or is greater than or equal to 4, an undefined value\nis returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupQuadSwapDiagonal",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_quad` is enabled.",
        "The function `subgroupQuadSwapDiagonal()` swaps the `value`s, within the\nquad diagonally.  This would result in the following transformation of the\nquad:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupQuadSwapHorizontal",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_quad` is enabled.",
        "The function `subgroupQuadSwapHorizontal()` swaps the `value`s, within the\nquad horizontally.  This would result in the following transformation of the\nquad:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupQuadSwapVertical",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_quad` is enabled.",
        "The function `subgroupQuadSwapVertical()` swaps the `value`s, within the\nquad vertically.  This would result in the following transformation of the\nquad:"
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupShuffle",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "id"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_shuffle` is enabled.",
        "The function `subgroupShuffle()` returns the `value` whose\n`gl_SubgroupInvocationID` is equal to `id`.  If the `id` is an\ninactive invocation or is greater than or equal to `gl_SubgroupSize`, an\nundefined value is returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_shuffle"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupShuffleDown",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "delta"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_shuffle_relative` is\nenabled.",
        "The function `subgroupShuffleDown()` returns the `value` whose\n`gl_SubgroupInvocationID` is equal to this invocation's\n`gl_SubgroupInvocationID` plus `delta`.  If `gl_SubgroupInvocationID` plus\n`delta` is an inactive invocation or is greater than or equal to\n`gl_SubgroupSize`, an undefined value is returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupShuffleUp",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "delta"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_shuffle_relative` is\nenabled.",
        "The function `subgroupShuffleUp()` returns the `value` whose\n`gl_SubgroupInvocationID` is equal to this invocation's\n`gl_SubgroupInvocationID` minus `delta`.  If `gl_SubgroupInvocationID` minus\n`delta` is an inactive invocation or is less than zero, an undefined value\nis returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_basic",
        "GL_KHR_shader_subgroup_vote",
        "GL_KHR_shader_subgroup_arithmetic",
        "GL_KHR_shader_subgroup_ballot",
        "GL_KHR_shader_subgroup_shuffle",
        "GL_KHR_shader_subgroup_shuffle_relative",
        "GL_KHR_shader_subgroup_clustered",
        "GL_KHR_shader_subgroup_quad"
      ]
    },
    {
      "return_type": "genType",
      "name": "subgroupShuffleXor",
      "parameters": [
        {
          "type": "genType",
          "name": "value"
        },
        {
          "type": "uint",
          "name": "mask"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_shuffle` is enabled.",
        "The function `subgroupShuffleXor()` returns the `value` whose\n`gl_SubgroupInvocationID` is equal to the current invocation's\n`gl_SubgroupInvocationID` xored with `mask`.  If the calculated index is\nan inactive invocation or is greater than or equal to `gl_SubgroupSize`, an\nundefined value is returned."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_shuffle"
      ]
    },
    {
      "return_type": "genIType",
      "name": "subgroupXor",
      "parameters": [
        {
          "type": "genIType",
          "name": "value"
        }
      ],
      "description": [
        "Only usable if the extension `GL_KHR_shader_subgroup_arithmetic` is enabled.",
        "For genIType and genUType, the function `subgroupXor()` returns the bitwise\nXOR of all active invocation provided `value`s.  For genBType, the function\n`subgroupXor()` returns the logical exclusive OR of all active invocation\nprovided `value`s."
      ],
      "extensions": [
        "GL_KHR_shader_subgroup_arithmetic"
      ]
    },
    {
      "return_type": "genType",
      "name": "tan",
      "parameters": [
        {
          "type": "genType",
          "name": "angle"
        }
      ],
      "description": [
        "`tan` returns the trigonometric tangent of _angle_."
      ],
      "versions": [
        110,
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "tanh",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`tanh` returns the hyperbolic tangent of `x`. The hyperbolic tangent of `x` is computed as ` sinh (x) / cosh (x) `."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "terminateRayNV",
      "parameters": [],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsamplerBuffer",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "P"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler2DMS",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "sample",
          "name": "sample"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetch",
      "parameters": [
        {
          "type": "gsampler2DMSArray",
          "name": "sampler"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "sample",
          "name": "sample"
        }
      ],
      "description": [
        "`texelFetch` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "ivec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texelFetchOffset",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "ivec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`texelFetchOffset` performs a lookup of a single texel from texture coordinate _P_ in the texture bound to _sampler_. Before fetching the texel, the offset specified in _offset_ is added to _P_. _offset_ must be a constant expression. The array layer is specified in the last component of _P_ for array forms. The _lod_ parameter (if present) specifies the level-of-detail from which the texel will be fetched. The _sample_ parameter specifies which sample within the texel will be returned when reading from a multi-sample texure."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "samplerCubeShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "texture",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "sampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "texture",
      "parameters": [
        {
          "type": "gsamplerCubeArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "compare"
        }
      ],
      "description": [
        "`texture` samples texels from the texture bound to _sampler_ at texture coordinate _P_. An optional bias, specified in _bias_ is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.",
        "For _shadow_ forms, when _compare_ is present, it is used as `D_sub` and the array layer is specified in `_P_.w`. When _compare_ is not present, the last component of _P_ is used as `D_sub` and the array layer is specified in the second to last component of _P_. (The second component of _P_ is unused for _1D_ shadow lookups.)",
        "For non-shadow variants, the array layer comes from the last component of _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureBlockMatchSADQCOM",
      "parameters": [
        {
          "type": "sampler2D",
          "name": "target"
        },
        {
          "type": "uvec2",
          "name": "targetCoord"
        },
        {
          "type": "sampler2D",
          "name": "reference"
        },
        {
          "type": "uvec2",
          "name": "refCoord"
        },
        {
          "type": "uvec2",
          "name": "blockSize"
        }
      ],
      "description": [
        "Block matching operation measures the      \n correlation (or similarity) of the target  \n block and reference block.  targetCoord    \n and refCoord specify the bottom-left corner\n of the block in target and reference       \n images. The error metric is the Sum of     \n Absolute Differences (SAD)."
      ],
      "extensions": [
        "GL_QCOM_image_processing"
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureBlockMatchSSDQCOM",
      "parameters": [
        {
          "type": "sampler2D",
          "name": "target"
        },
        {
          "type": "uvec2",
          "name": "targetCoord"
        },
        {
          "type": "sampler2D",
          "name": "reference"
        },
        {
          "type": "uvec2",
          "name": "refCoord"
        },
        {
          "type": "uvec2",
          "name": "blockSize"
        }
      ],
      "description": [
        "Block matching operation measures the      \n correlation (or similarity) of the target  \n block and reference block.  TargetCoord    \n and refCoord specify the bottom-left corner\n of the block in target and reference       \n images. The error metric is the Sum of     \n Square Differences (SSD)."
      ],
      "extensions": [
        "GL_QCOM_image_processing"
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureBoxFilterQCOM",
      "parameters": [
        {
          "type": "sampler2D",
          "name": "tex"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "boxSize"
        }
      ],
      "description": [
        "Linear operation taking average of pixels  \n within the spatial region described by     \n boxSize.  The box is centered at coordinate\n P and has width and height of boxSize.x    \n and boxSize.y."
      ],
      "extensions": [
        "GL_QCOM_image_processing"
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsamplerCubeShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsamplerCubeArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGather",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        }
      ],
      "description": [
        "`textureGather` returns the value:",
        "",
        "",
        "If specified, the value of _comp_ must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffset",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGatherOffset` returns the value:",
        "",
        "",
        "It perfoms as textureGather but with _offset_ applied as described in textureOffset, except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.",
        "If specified, the value of _comp_ must ba constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If _comp_ is not specified, it is treated as 0, selecting the x component of each texel to generate the result."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        },
        {
          "optional": true,
          "type": "int",
          "name": "comp"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureGatherOffsets",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "refZ"
        },
        {
          "type": "ivec2[4]",
          "name": "offsets"
        }
      ],
      "description": [
        "`textureGatherOffsets` operates identically to textureGatherOffset, except that _offsets_ is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in _offsets_ as a (u, v) coordinate offset to _P_, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel `i_0 i_0` of that footprint. The specified values in _offsets_ must be set with constant integral expressions."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "dPdx"
        },
        {
          "type": "vec3",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "dPdx"
        },
        {
          "type": "vec3",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGrad",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "dPdx"
        },
        {
          "type": "vec3",
          "name": "dPdy"
        }
      ],
      "description": [
        "`textureGrad` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. Set:",
        "` δs / δx = δP / δx for a 1D texture, δP.s / δx otherwise `",
        "` δs / δy = δP / δy for a 1D texture, δP.s / δy otherwise `",
        "` δt / δx = 0.0 for a 1D texture, δP.t / δx otherwise `",
        "` δt / δy = 0.0 for a 1D texture, δP.t / δy otherwise `",
        "` δr / δx = 0.0 for a 1D or 2D texture, δP.p / δx otherwise `",
        "` δr / δy = 0.0 for a 1D or 2D texture, δP.p / δy otherwise `",
        "For the cube version, the partial derivatives of _P_ are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "dPdx"
        },
        {
          "type": "vec3",
          "name": "dPdy"
        },
        {
          "type": "ivec3",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureGradOffset",
      "parameters": [
        {
          "type": "sampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureGradOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with explicit texture coordinate gradiends as specified in _dPdx_ and _dPdy_. An explicit offset is also supplied in _offset_. `textureGradOffset` consumes _dPdx_ and _dPdy_ as textureGrad and _offset_ as textureOffset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLod",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLod",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLod",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLod",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureLod` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. _lod_ specifies `λ_base` and sets the partial derivatives as follows:",
        "```\n   δu  /  δx   =  0  ,       δv  /  δx   =  0  ,       δw  /  δx   =  0    \n   δu  /  δy   =  0  ,       δv  /  δy   =  0  ,       δw  /  δy   =  0    \n\n```\n"
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec3",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureLodOffset",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureLodOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an explicit level-of-detail as specified in _lod_. Behavior is the same as in textureLod except that before sampling, _offset_ is added to _P_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec3",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "sampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureOffset",
      "parameters": [
        {
          "type": "sampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureOffset` performs a texture lookup at coordinate _P_ from the texture bound to _sampler_ with an an additional offset, specified in texels in _offset_ that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.",
        "Note that _offset_ does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProj",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProj",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProj",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        }
      ],
      "description": [
        "`textureProj` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in texture."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "pDx"
        },
        {
          "type": "float",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "pDx"
        },
        {
          "type": "float",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "pDx"
        },
        {
          "type": "vec3",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "pDx"
        },
        {
          "type": "float",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGrad",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "pDx"
        },
        {
          "type": "vec2",
          "name": "pDy"
        }
      ],
      "description": [
        "`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGrad, passing _dPdx_ and _dPdy_ as gradients."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec3",
          "name": "dPdx"
        },
        {
          "type": "vec3",
          "name": "dPdy"
        },
        {
          "type": "ivec3",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "dPdx"
        },
        {
          "type": "float",
          "name": "dPdy"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjGradOffset",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "vec2",
          "name": "dPdx"
        },
        {
          "type": "vec2",
          "name": "dPdy"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureGradOffset, passing _dPdx_ and _dPdy_ as gradients, and _offset_ as the offset."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjLod",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        }
      ],
      "description": [
        "`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLod, with _lod_ used to specify the level-of-detail from which the texture will be sampled."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec3",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "int",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjLodOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "float",
          "name": "lod"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureLodOffset, with _lod_ used to specify the level-of-detail from which the texture will be sampled and _offset_ used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec3",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "int",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        },
        {
          "optional": true,
          "type": "float",
          "name": "bias"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "gvec4",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler2DRect",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "float",
      "name": "textureProjOffset",
      "parameters": [
        {
          "type": "gsampler2DRectShadow",
          "name": "sampler"
        },
        {
          "type": "vec4",
          "name": "P"
        },
        {
          "type": "ivec2",
          "name": "offset"
        }
      ],
      "description": [
        "`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from _P_, not including the last component of _P_, are divided by the last component of _P_. The resulting `3**rd` component of _P_ in the shadow forms is used as `D_ref`. After these values are computed, the texture lookup proceeds as in textureOffset, with the _offset_ used to offset the computed texture coordinates."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler2DDArray",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler1DShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler2DShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsamplerCubeShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler1DArrayShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsampler2DArrayShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gsamplerCubeArrayShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with _sampler_.",
        "If called on an incomplete texture, or if no texture is associated with _sampler_, zero is returned."
      ],
      "versions": [
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureQueryLevels",
      "parameters": [
        {
          "type": "gtexture1D",
          "name": "texture"
        }
      ],
      "extensions": [
        "GL_EXT_samplerless_texture_functions"
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsampler2DDArray",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "gsamplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "samplerCubeShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "float",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "sampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec2",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec2",
      "name": "textureQueryLod",
      "parameters": [
        {
          "type": "samplerCubeArrayShadow",
          "name": "sampler"
        },
        {
          "type": "vec3",
          "name": "P"
        }
      ],
      "description": [
        "_Available only in the fragment shader_, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the _x_ component of the return value. The computed level-of-detail relative to the base level is returned in the _y_ component of the return value.",
        "If called on an incomplete texture, the result of the operation is undefined."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureSamples",
      "parameters": [
        {
          "type": "gsampler2DMS",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSamples` returns the number of samples per texel of the texture bound to _sampler_."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureSamples",
      "parameters": [
        {
          "type": "gsampler2DMSArray",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSamples` returns the number of samples per texel of the texture bound to _sampler_."
      ],
      "versions": [
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureSamples",
      "parameters": [
        {
          "type": "gtexture2DMS",
          "name": "texture"
        }
      ],
      "extensions": [
        "GL_EXT_samplerless_texture_functions"
      ]
    },
    {
      "return_type": "int",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler1D",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler2D",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler3D",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsamplerCube",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureSize",
      "parameters": [
        {
          "type": "sampler1DShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "sampler2DShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "samplerCubeShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "samplerCubeArray",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "samplerCubeArrayShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsamplerRect",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsamplerRectShadow",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler1DArray",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler2DArray",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "sampler1DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "sampler2DArrayShadow",
          "name": "sampler"
        },
        {
          "type": "int",
          "name": "lod"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "int",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsamplerBuffer",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler2DMS",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec3",
      "name": "textureSize",
      "parameters": [
        {
          "type": "gsampler2DMSArray",
          "name": "sampler"
        }
      ],
      "description": [
        "`textureSize` returns the dimensions of level _lod_ (if present) of the texture bound to _sampler_. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "textureWeightedQCOM",
      "parameters": [
        {
          "type": "sampler2D",
          "name": "tex"
        },
        {
          "type": "vec2",
          "name": "P"
        },
        {
          "type": "sampler2DArray",
          "name": "weight"
        }
      ],
      "description": [
        "weighted sample operation multiplies       \n a 2D kernel of filter weights with a corr- \n esponding region of sampled texels and     \n sums the results to produce the output     \n value."
      ],
      "extensions": [
        "GL_QCOM_image_processing"
      ]
    },
    {
      "return_type": "void",
      "name": "traceNV",
      "parameters": [
        {
          "type": "accelerationStructureNV",
          "name": "topLevel"
        },
        {
          "type": "uint",
          "name": "rayFlags"
        },
        {
          "type": "uint",
          "name": "cullMask"
        },
        {
          "type": "uint",
          "name": "sbtRecordOffset"
        },
        {
          "type": "uint",
          "name": "sbtRecordStride"
        },
        {
          "type": "uint",
          "name": "missIndex"
        },
        {
          "type": "vec3",
          "name": "origin"
        },
        {
          "type": "float",
          "name": "Tmin"
        },
        {
          "type": "vec3",
          "name": "direction"
        },
        {
          "type": "float",
          "name": "Tmax"
        },
        {
          "type": "int",
          "name": "payload"
        }
      ],
      "extensions": [
        "GL_NV_ray_tracing"
      ]
    },
    {
      "return_type": "mat2",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        120,
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2x3",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat3x2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat2x4",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat4x2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3x2",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat2x3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat3x4",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat4x3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4x2",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat2x4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "mat4x3",
      "name": "transpose",
      "parameters": [
        {
          "type": "mat3x4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2x3",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat3x2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat2x4",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat4x2",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3x2",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat2x3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat3x4",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat4x3",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4x2",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat2x4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "dmat4x3",
      "name": "transpose",
      "parameters": [
        {
          "type": "dmat3x4",
          "name": "m"
        }
      ],
      "description": [
        "`transpose` returns the transpose of the matrix _m_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genType",
      "name": "trunc",
      "parameters": [
        {
          "type": "genType",
          "name": "x"
        }
      ],
      "description": [
        "`trunc` returns a a value equal to the nearest integer to _x_ whose absolute value is not larger than the absolute value of _x_."
      ],
      "versions": [
        130,
        140,
        150,
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genDType",
      "name": "trunc",
      "parameters": [
        {
          "type": "genDType",
          "name": "x"
        }
      ],
      "description": [
        "`trunc` returns a a value equal to the nearest integer to _x_ whose absolute value is not larger than the absolute value of _x_."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "uaddCarry",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        },
        {
          "modifiers": "out",
          "type": "genUType",
          "name": "carry"
        }
      ],
      "description": [
        "`uaddCarry` adds two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a carry output. The result is the sum of _x_ and _y_ modulo `2**32`. The value _carry_ is set to 0 if the sum is less than `2**32` and to 1 otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genF16Type",
      "name": "uint16BitsToFloat16",
      "parameters": [
        {
          "type": "genU16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genF16Type",
      "name": "uint16BitsToHalf",
      "parameters": [
        {
          "type": "genU16Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genDType",
      "name": "uint64BitsToDouble",
      "parameters": [
        {
          "type": "genU64Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "genType",
      "name": "uintBitsToFloat",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        }
      ],
      "description": [
        "`intBitsToFloat` and `uintBitsToFloat` return the encoding passed in parameter _x_ as a floating-point value. If the encoding of a NaN is passed in _x_, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter _x_, the resulting floating-point value is the corresponding (positive or negative) floating point infinity."
      ],
      "versions": [
        330,
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genF32Type",
      "name": "uintBitsToFloat",
      "parameters": [
        {
          "type": "genU32Type",
          "name": "value"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "void",
      "name": "umulExtended",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        },
        {
          "modifiers": "out",
          "type": "genUType",
          "name": "msb"
        },
        {
          "modifiers": "out",
          "type": "genUType",
          "name": "lsb"
        }
      ],
      "description": [
        "`umulExtended` and `imulExtended` perform multiplication of the two 32-bit integer quantities _x_ and _y_, producing a 64-bit integer result. The 32 least significant bits of this product are returned in _lsb_ and the 32 most significant bits are returned in _msb_. `umulExtended` and `imulExtended` perform unsigned and signed multiplication, respectively."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "i16vec4",
      "name": "unpack16",
      "parameters": [
        {
          "type": "int64_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "i32vec2",
      "name": "unpack32",
      "parameters": [
        {
          "type": "int64_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "i8vec4",
      "name": "unpack8",
      "parameters": [
        {
          "type": "int32_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uvec2",
      "name": "unpackDouble2x32",
      "parameters": [
        {
          "type": "double",
          "name": "d"
        }
      ],
      "description": [
        "`unpackDouble2x32` returns a two-component unsigned integer vector representation of _d_. The bit-level representation of _d_ is preserved. The first component of the returned vector contains the 32 least significant bits of the double; the second component consists the 32 most significant bits."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "f16vec2",
      "name": "unpackFloat2x16",
      "parameters": [
        {
          "type": "uint32_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "vec2",
      "name": "unpackHalf2x16",
      "parameters": [
        {
          "type": "uint",
          "name": "v"
        }
      ],
      "description": [
        "`unpackHalf2x16` returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most-significant bits of v."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "ivec2",
      "name": "unpackInt2x32",
      "parameters": [
        {
          "type": "int64_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "vec2",
      "name": "unpackSnorm2x16",
      "parameters": [
        {
          "type": "uint",
          "name": "p"
        }
      ],
      "description": [
        "`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter _p_ into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.",
        "The conversion for unpacked fixed point value _f_ to floating-point is performed as follows:",
        "`packUnorm2x16`: `f / 65535.0`",
        "`packSnorm2x16`: `clamp(f / 32727.0, -1.0, 1.0)`",
        "`packUnorm4x8`: `f / 255.0`",
        "`packSnorm4x8`: `clamp(f / 127.0, -1.0, 1.0)`",
        "",
        "The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits."
      ],
      "versions": [
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "unpackSnorm4x8",
      "parameters": [
        {
          "type": "uint",
          "name": "p"
        }
      ],
      "description": [
        "`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter _p_ into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.",
        "The conversion for unpacked fixed point value _f_ to floating-point is performed as follows:",
        "`packUnorm2x16`: `f / 65535.0`",
        "`packSnorm2x16`: `clamp(f / 32727.0, -1.0, 1.0)`",
        "`packUnorm4x8`: `f / 255.0`",
        "`packSnorm4x8`: `clamp(f / 127.0, -1.0, 1.0)`",
        "",
        "The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "u16vec2",
      "name": "unpackUint2x16",
      "parameters": [
        {
          "type": "uint32_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "uvec2",
      "name": "unpackUint2x32",
      "parameters": [
        {
          "type": "uint64_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "u16vec4",
      "name": "unpackUint4x16",
      "parameters": [
        {
          "type": "uint64_t",
          "name": "v"
        }
      ],
      "extensions": [
        "GL_EXT_shader_explicit_arithmetic_types",
        "GL_EXT_shader_explicit_arithmetic_types_int8",
        "GL_EXT_shader_explicit_arithmetic_types_int16",
        "GL_EXT_shader_explicit_arithmetic_types_int32",
        "GL_EXT_shader_explicit_arithmetic_types_int64",
        "GL_EXT_shader_explicit_arithmetic_types_float16",
        "GL_EXT_shader_explicit_arithmetic_types_float32",
        "GL_EXT_shader_explicit_arithmetic_types_float64"
      ]
    },
    {
      "return_type": "vec2",
      "name": "unpackUnorm2x16",
      "parameters": [
        {
          "type": "uint",
          "name": "p"
        }
      ],
      "description": [
        "`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter _p_ into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.",
        "The conversion for unpacked fixed point value _f_ to floating-point is performed as follows:",
        "`packUnorm2x16`: `f / 65535.0`",
        "`packSnorm2x16`: `clamp(f / 32727.0, -1.0, 1.0)`",
        "`packUnorm4x8`: `f / 255.0`",
        "`packSnorm4x8`: `clamp(f / 127.0, -1.0, 1.0)`",
        "",
        "The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "vec4",
      "name": "unpackUnorm4x8",
      "parameters": [
        {
          "type": "uint",
          "name": "p"
        }
      ],
      "description": [
        "`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter _p_ into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.",
        "The conversion for unpacked fixed point value _f_ to floating-point is performed as follows:",
        "`packUnorm2x16`: `f / 65535.0`",
        "`packSnorm2x16`: `clamp(f / 32727.0, -1.0, 1.0)`",
        "`packUnorm4x8`: `f / 255.0`",
        "`packSnorm4x8`: `clamp(f / 127.0, -1.0, 1.0)`",
        "",
        "The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits."
      ],
      "versions": [
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "genUType",
      "name": "usubBorrow",
      "parameters": [
        {
          "type": "genUType",
          "name": "x"
        },
        {
          "type": "genUType",
          "name": "y"
        },
        {
          "modifiers": "out",
          "type": "genUType",
          "name": "borrow"
        }
      ],
      "description": [
        "`usubBorrow` subtracts two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a borrow output. The result is the difference of _x_ and _y_ if non-negative, or `2**32` plus that difference otherwise. The value _borrow_ is set to 0 if _x_ ≥ _y_ and to 1 otherwise."
      ],
      "versions": [
        400,
        410,
        420,
        430,
        440,
        450
      ]
    },
    {
      "return_type": "void",
      "name": "writePackedPrimitiveIndices4x8NV",
      "parameters": [
        {
          "type": "uint",
          "name": "indexOffset"
        },
        {
          "type": "uint",
          "name": "packedIndices"
        }
      ],
      "extensions": [
        "GL_NV_mesh_shader"
      ]
    }
  ]
}